---
title: "常用API"
date: 2020-04-04
category: React-vue
permalink: "2020-04-04-React-常用API"
---

## setState

直接设置需要的值

```jsx
this.setState({
	counter: 2
})
```

如果后续状态取决于当前状态，建议使用如下方式

```jsx
this.setState((preState, props) => {
	return { counter: preState.counter + 1 }
})
```

`setState`执行是批量的，如果对同一个进行多次修改，只有最后一个会生效

```jsx
// 最终结果是+1
this.setState({
    counter: this.state.counter + 1
})
this.setState({
    counter: this.state.counter + 1
})
this.setState({
    counter: this.state.counter + 1
})
```

如果想修改的值向下传递

- 回调的方式（推荐）

	```jsx
  // 最终结果是+3
  this.setState((preState, props) => ({ counter: preState.counter + 1 }))
  this.setState((preState, props) => ({ counter: preState.counter + 1 }))
  this.setState((preState, props) => ({ counter: preState.counter + 1 }))
  ```

- setTimeout

  ```jsx
  // 在定时器中执行this.setState
  setTimeout(() => {
	changVal()
  }, 0)
  ```
  
- 使用原生事件绑定changVal



## 生命周期

**v17**即将废弃的3个生命周期函数，目前要用，需加上UNSAFE_

- `componentWillMount`：组件挂载之前触发
- `componentWillReceiveProps`：已挂载的组件的`props`传值发生变化时触发
- `componentWillUpdate`：组件更新之前触发

引入了两个新的生命周期函数

- `Static getDerivedStateFromProps`
  - 当父组件或本组件的值发生变化后，在`render`前，都会触发
  - 在初始挂载及后续更新时都会被调用
  - 返回的对象会被当做`this.setState`的参数进行设置
  - 返回`null`则，不触发`render`
- `getSnapshotBeforeUpdate`
  - 组件`update`时获取上一次的`props`和`state`
  - 然后将`return`的值传递给`componentDidUpdate`

### 变更缘由

React v16推出的[Fiber](https://zhuanlan.zhihu.com/p/26027085)之后就不合适了，因为如果要开启async rendering，在render函数之前
的所有函数，都有可能被执行多次

原来（React v16.0前）的生命周期有哪些是在render前执行

- `componentWillMount`
- `componentWillReceiveProps`
- `componentWillUpdate`  
- `shouldComponentUpdate`

由于使用了`Fiber`架构，所以以上生命周期可能会被执行多次，如果该生命周期中有`HTTP`请求，那该请求将被无谓地多次调用。所以`react`将前三个生命周期，都废除了。

取而代之的是`Static getDerivedStateFromProps`

### 最新生命周期

![](https://upload-images.jianshu.io/upload_images/12185313-85b3010f0b8b7d16.png)

## Context

> 组件跨层级通信，常用于组件库。
>
> vue中的provide&inject来源于此

在`context`中有两个角色

- `Provider`：外层提供数据的组件
- `Consumer`：内层获取数据的组件

### 使用demo1

**myContext.js**

定义一个`context`

```jsx
import React from 'react'
const Context = React.createContext()
const Provider = Context.Provider
const Consumer = Context.Consumer

export { Provider, Consumer }
```

**index.jsx**

顶级组件使用`Provider`，向下传递数据

```jsx
import React from 'react'
import OneLevel from './oneLevel'
import { Provider } from './myContext'

const store = {
  userInfo: {
    userId: 1,
    userName: 'smw'
  }
}

function MyContext(props) {
  return (
    <Provider value={store}>
      <div>
        Context
        <OneLevel />
      </div>
    </Provider>
  )
}
```

**oneLevel.jsx**

使用`Consumer`将数据传给子组件，这样子组件就可以获取

```jsx
import React from 'react'
import TwoLevel from './twoLevel'
import { Consumer } from './myContext'

function OneLevel(props) {
  return (
    <div>
      OneLevel
      <Consumer>{ctx => <TwoLevel {...ctx} />}</Consumer>
    </div>
  )
}
```

### 使用demo2

顶级使用`Provider`传递后，在需要使用的地方使用`TwoLevel.contextType = Context`

在`render`中就可以使用`this.context`获取到数据

但是仅限`class`组件

```jsx
import React, { Component } from 'react'
import { Context } from './myContext'

class TwoLevel extends Component {
  render() {
    console.log(this.context)
    return <div>TwoLevel</div>
  }
}
TwoLevel.contextType = Context

export default TwoLevel
```



## Composition

> 组件复合，类似vue的slot功能

**不具名复合**

直接传入

```jsx
import React from 'react';
import HasChild from "./hasChild";

function Compose(props) {
    return (
        <div>
            Compose
            <HasChild>
                <p>复合内容</p>
            </HasChild>
        </div>
    );
}
```

**具名复合**

以对象的形式传入

```jsx
import React from 'react'
import HasChild from './hasChild'

function Compose(props) {
  return (
    <div>
      Compose
      <HasChild>
        {{
          title: 'title',
          btn: <button>btn</button>
        }}
      </HasChild>
    </div>
  )
}
```



## HOC

高阶组件是一个工厂函数，它接收一个组件并返回另一个组件。

可用于扩展组件功能，可参考ant的form表单组件

一个简单的demo，封装了一个可以提供title的高阶组件

```jsx
function Child(props) {
  return <div>Child</div>
}

const AddTitle = (Cmp) => (props) => {
  // props:会通过hoc传递进来，最终传递给被封装的组件
  return (
    <div>
      <h1>Title</h1>
      <Cmp {...props} />
    </div>
  )
}

const Hoc = AddTitle(Child)

export default Hoc
```

以装饰器的形式封装Hoc

```jsx
const withLog = (Cmp) => (props) => {
  console.log('withLog')
  return <Cmp {...props} />
}

@withLog
class Dec extends Component {
  render() {
    return <div>123123</div>
  }
}

export default Dec
```



## Hooks

### useState

用来初始化状态和修改状态，类似`setState`

```jsx
const [date, setDate] = useState(new Date())
setDate(new Date())
```

### useEffect

增加执行副作用操作的能力

> 副作用（Side Effect）是指 function 做了和本身运算返回值无
> 关的事，如：修改了全局变量、修改了传的参数、console.log()，所以 ajax 操作，修改 dom 都是算作副作用。  

不设置第二个参数，每次状态发生变化都会触发

```
useEffect(() => {

})
```

第二个参数设置空数组只会执行一次

```jsx
useEffect(() => {

}, [])
```

第二个参数设置某几个具体的状态，只有在该状态发生变化时，才会触发

```jsx
useEffect(() => {

}, [data1,data2])
```

空数组设置返回函数，有在组件销毁前执行

```jsx
useEffect(() => {
    return ()=>{

    }
}, [])
```

