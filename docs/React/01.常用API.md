---
title: "常用API"
date: 2020-04-04
category: React-vue
permalink: "2020-04-04-React-常用API"
---

## setState

直接设置需要的值

```jsx
this.setState({
	counter: 2
})
```

如果后续状态取决于当前状态，建议使用如下方式

```jsx
this.setState((preState, props) => {
	return { counter: preState.counter + 1 }
})
```

`setState`执行是批量的，如果对同一个进行多次修改，只有最后一个会生效

```jsx
// 最终结果是+1
this.setState({
    counter: this.state.counter + 1
})
this.setState({
    counter: this.state.counter + 1
})
this.setState({
    counter: this.state.counter + 1
})
```

如果想修改的值向下传递

- 回调的方式（推荐）

	```jsx
  // 最终结果是+3
  this.setState((preState, props) => ({ counter: preState.counter + 1 }))
  this.setState((preState, props) => ({ counter: preState.counter + 1 }))
  this.setState((preState, props) => ({ counter: preState.counter + 1 }))
  ```

- setTimeout

  ```jsx
  // 在定时器中执行this.setState
  setTimeout(() => {
	changVal()
  }, 0)
  ```
  
- 使用原生事件绑定changVal



## 生命周期

**v17**即将废弃的3个生命周期函数，目前要用，需加上UNSAFE_

- `componentWillMount`：组件挂载之前触发
- `componentWillReceiveProps`：已挂载的组件的`props`传值发生变化时触发
- `componentWillUpdate`：组件更新之前触发

引入了两个新的生命周期函数

- `Static getDerivedStateFromProps`
  - 当父组件或本组件的值发生变化后，在`render`前，都会触发
  - 在初始挂载及后续更新时都会被调用
  - 返回的对象会被当做`this.setState`的参数进行设置
  - 返回`null`则，不触发`render`
- `getSnapshotBeforeUpdate`
  - 组件`update`时获取上一次的`props`和`state`
  - 然后将`return`的值传递给`componentDidUpdate`

### 变更缘由

React v16推出的[Fiber](https://zhuanlan.zhihu.com/p/26027085)之后就不合适了，因为如果要开启async rendering，在render函数之前
的所有函数，都有可能被执行多次

原来（React v16.0前）的生命周期有哪些是在render前执行

- `componentWillMount`
- `componentWillReceiveProps`
- `componentWillUpdate`  
- `shouldComponentUpdate`

由于使用了`Fiber`架构，所以以上生命周期可能会被执行多次，如果该生命周期中有`HTTP`请求，那该请求将被无谓地多次调用。所以`react`将前三个生命周期，都废除了。

取而代之的是`Static getDerivedStateFromProps`

### 最新生命周期

![](https://upload-images.jianshu.io/upload_images/12185313-85b3010f0b8b7d16.png)

## Context

> 组件跨层级通信，常用于组件库。
>
> vue中的provide&inject来源于此

在`context`中有两个角色

- `Provider`：外层提供数据的组件
- `Consumer`：内层获取数据的组件

### 使用demo1

**myContext.js**

定义一个`context`

```jsx
import React from 'react'
const Context = React.createContext()
const Provider = Context.Provider
const Consumer = Context.Consumer

export { Provider, Consumer }
```

**index.jsx**

顶级组件使用`Provider`，向下传递数据

```jsx
import React from 'react'
import OneLevel from './oneLevel'
import { Provider } from './myContext'

const store = {
  userInfo: {
    userId: 1,
    userName: 'smw'
  }
}

function MyContext(props) {
  return (
    <Provider value={store}>
      <div>
        Context
        <OneLevel />
      </div>
    </Provider>
  )
}
```

**oneLevel.jsx**

使用`Consumer`将数据传给子组件，这样子组件就可以获取

```jsx
import React from 'react'
import TwoLevel from './twoLevel'
import { Consumer } from './myContext'

function OneLevel(props) {
  return (
    <div>
      OneLevel
      <Consumer>{ctx => <TwoLevel {...ctx} />}</Consumer>
    </div>
  )
}
```

### 使用demo2

顶级使用`Provider`传递后，在需要使用的地方使用`TwoLevel.contextType = Context`

在`render`中就可以使用`this.context`获取到数据

但是仅限`class`组件

```jsx
import React, { Component } from 'react'
import { Context } from './myContext'

class TwoLevel extends Component {
  render() {
    console.log(this.context)
    return <div>TwoLevel</div>
  }
}
TwoLevel.contextType = Context

export default TwoLevel
```



## Composition

> 组件复合，类似vue的slot功能

**不具名复合**

直接传入

```jsx
import React from 'react';
import HasChild from "./hasChild";

function Compose(props) {
    return (
        <div>
            Compose
            <HasChild>
                <p>复合内容</p>
            </HasChild>
        </div>
    );
}
```

**具名复合**

以对象的形式传入

```jsx
import React from 'react'
import HasChild from './hasChild'

function Compose(props) {
  return (
    <div>
      Compose
      <HasChild>
        {{
          title: 'title',
          btn: <button>btn</button>
        }}
      </HasChild>
    </div>
  )
}
```

