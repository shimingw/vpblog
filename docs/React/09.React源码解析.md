---
title: "React源码解析"
date: 2020-05-23
category: React
permalink: "2020-05-23-React-React源码解析"
---

> 源码版本 16.13.1

## jsx

下面是一段常见的`react`代码，有人可能会奇怪`js`里写`html`究竟是怎么回事，能跑的起来吗

```jsx
function Home(props) {
  return (
    <div>
      <h1>hello</h1>
      <h1>world</h1>
    </div>
  )
}

class App extends React.Component {
  render() {
    return (
      <Home />
    );
  }
}
```

直接运行当然是跑不起来的，`JSX` 是一种 `JavaScript` 的语法扩展。`React` 中使用 `JSX` 来描述用户界面。

既然是一种语法扩展，`JSX`语法需要经过`babel`编译才能够执行。

直接使用`@babel/preset-react`这个预设就可使`babel`具备编译`JSX`的功能

编译后的文件为（[可以点击体验一下](https://www.babeljs.cn/repl#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=FAMwrgdgxgLglgewgAgBIILYFMAUAHAJwTwGcBKZAb2GWQKxjAJRxtuQB4ATOANwD427TgAsAjPxFYANtIQcA9OMHDaHZQHcEBaV0XKhnBTwFsywAL7BgUaQEMSJZAEE8eZFgAeMLBC5OAJSw7WAA6AGFMPCRfGCo2ej8sAhwKamF6RmZkVlVOdGxkBRV2MgBuNisrIA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=react&prettier=false&targets=&version=7.9.6&externalPlugins=)）：

```js
function Home(props) {
  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("h1", null, "hello"), /*#__PURE__*/React.createElement("h1", null, "world"));
}

class App extends React.Component {
  render() {
    return /*#__PURE__*/React.createElement(Home, null);
  }

}
```

ps：`vue`中有一个`compile`方法就是实现以上的功能，在`webpack`中被抽离出来成为了`vue-loader`

## createElement

```js
/**
 * @param {*} type		节点类型
 * @param {*} config	节点属性
 * @param {*} children	子节点
 * @returns
 */
export function createElement(type, config, children) {
  let propName;

  // Reserved names are extracted
  const props = {};

  let key = null;
  let ref = null;
  let self = null;
  let source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      if (__DEV__) {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (
        hasOwnProperty.call(config, propName) &&
        !RESERVED_PROPS.hasOwnProperty(propName)
      ) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  const childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    const childArray = Array(childrenLength);
    for (let i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (__DEV__) {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (__DEV__) {
    if (key || ref) {
      const displayName =
        typeof type === 'function'
          ? type.displayName || type.name || 'Unknown'
          : type;
      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }
      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}
```

### ReactElement

`createElement`调用`ReactElement`创建虚拟dom

```js
const ReactElement = function(type, key, ref, self, source, owner, props) {
  const element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner,
  };

  if (__DEV__) {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false,
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self,
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source,
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
```

### 最终返回的数据结构

```js
const element = {
    // 这个标签允许我们将其唯一地标识为一个React元素
    $$typeof: REACT_ELEMENT_TYPE,	//Symbol(react.element)

    // 元素的内置属性
    // 原生元素为一个string
    // 类组件为一个class类
    // 函数式组件为一个function
    type: type,
    key: key,
    ref: ref,
    props: props,

    // 记录负责创建此元素的组件。即为父组件
    // 如果是顶层组件则为null
    _owner: owner,
};
```

## ReactDOM**.**render

在`render`中

- 判断了`container`是否合法
- 调用`legacyRenderSubtreeIntoContainer`

```js
export function render(
  element: React$Element<any>,
  container: Container,
  callback: ?Function,
) {
  // 判断container是否合法
  invariant(
    isValidContainer(container),
    'Target container is not a DOM element.',
  );
  if (__DEV__) {
    const isModernRoot =
      isContainerMarkedAsRoot(container) &&
      container._reactRootContainer === undefined;
    if (isModernRoot) {
      console.error(
        'You are calling ReactDOM.render() on a container that was previously ' +
          'passed to ReactDOM.createRoot(). This is not supported. ' +
          'Did you mean to call root.render(element)?',
      );
    }
  }
  return legacyRenderSubtreeIntoContainer(
    null,
    element,
    container,
    false,
    callback,
  );
}
```

### legacyRenderSubtreeIntoContainer

- 调用`legacyCreateRootFromDOMContainer`初始化挂载

### legacyCreateRootFromDOMContainer

- 判断是否是服务端渲染
- 如果不是服务端渲染则把`container`中的`html`元素都移除
- 调用`createLegacyRoot`

### createLegacyRoot

- 返回的数据结构

  ```js
  export type RootType = {
    render(children: ReactNodeList): void,
    unmount(): void,
    _internalRoot: FiberRoot,
    ...
  };
  ```

- 实例化`ReactDOMBlockingRoot`

### ReactDOMBlockingRoot

- 调用`createRootImpl`

### createRootImpl

- 调用`createContainer`

### createContainer

- 调用`createFiberRoot`

### createFiberRoot

- 实例化`FiberRootNode`获取`FiberRoot`
- 调用`createHostRootFiber`方法获取`uninitializedFiber`
- 将`uninitializedFiber`赋值到`root.current`？？？
- 将`root`赋值到`uninitializedFiber.stateNode`？？？
- 调用`initializeUpdateQueue`方法
  - 创建一个`queue`
  - 将`queue`赋值到`uninitializedFiberz.updateQueue`
- 返回`root`

```js
export function createFiberRoot(
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
): FiberRoot {
  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);
  if (enableSuspenseCallback) {
    root.hydrationCallbacks = hydrationCallbacks;
  }

  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  const uninitializedFiber = createHostRootFiber(tag);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  initializeUpdateQueue(uninitializedFiber);

  return root;
}
```

### FiberRootNode

```js
function FiberRootNode(containerInfo, tag, hydrate) {
  this.tag = tag;
  this.current = null;
  this.containerInfo = containerInfo;
  this.pendingChildren = null;
  this.pingCache = null;
  this.finishedExpirationTime = NoWork;
  this.finishedWork = null;
  this.timeoutHandle = noTimeout;
  this.context = null;
  this.pendingContext = null;
  this.hydrate = hydrate;
  this.callbackNode = null;
  this.callbackPriority_old = NoPriority;
  this.firstPendingTime = NoWork;
  this.lastPendingTime = NoWork;
  this.firstSuspendedTime = NoWork;
  this.lastSuspendedTime = NoWork;
  this.nextKnownPendingLevel = NoWork;
  this.lastPingedTime = NoWork;
  this.lastExpiredTime = NoWork;
  this.mutableSourceLastPendingUpdateTime = NoWork;

  if (enableSchedulerTracing) {
    this.interactionThreadID = unstable_getThreadID();
    this.memoizedInteractions = new Set();
    this.pendingInteractionMap_old = new Map();
  }
  if (enableSuspenseCallback) {
    this.hydrationCallbacks = null;
  }
}
```

最终返回的`root`（`container`）

```json
{
    "tag":0,
    "current":null,
    "containerInfo":{

    },
    "pendingChildren":null,
    "pingCache":null,
    "finishedExpirationTime":0,
    "finishedWork":null,
    "timeoutHandle":-1,
    "context":null,
    "pendingContext":null,
    "hydrate":false,
    "callbackNode":null,
    "callbackPriority_old":90,
    "firstPendingTime":0,
    "lastPendingTime":0,
    "firstSuspendedTime":0,
    "lastSuspendedTime":0,
    "nextKnownPendingLevel":0,
    "lastPingedTime":0,
    "lastExpiredTime":0,
    "mutableSourceLastPendingUpdateTime":0,
    "interactionThreadID":1,
    "memoizedInteractions":{

    },
    "pendingInteractionMap_old":{

    }
}
```

