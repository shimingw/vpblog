---
title: "React-hooks入坑指南"
date: 2020-09-01
category: React
permalink: "2020-09-01-React-ReactHooks入坑指南"
---

## 前言

如果你是在使用`React >= 16.8`的版本，那么你可以使用`hooks`在编写你的组件，它可以让你在不编写 `class` 的情况下使用 `state` 以及其他的 `React` 特性。



## 为什么要使用Hooks

1. 提供代码逻辑复用的另一种选择（[自定义 Hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)），其他选择[Render Props](https://zh-hans.reactjs.org/docs/render-props.html)、[HOC](https://zh-hans.reactjs.org/docs/higher-order-components.html)、[mixins（不推荐使用）](https://zh-hans.reactjs.org/docs/react-without-es6.html#mixins)
2. 没有了class复杂的生命周期，组件写起来更清爽。
3. 官方推荐使用，后续官网应该会不断完善`Hooks`



## HooksApi

### useState

通常我们在使用class组件时，会在`constructor`中初始化`state`。`constructor`只会在组件实例化时执行一次。同样的，使用`useState`可以实现上述的操作。

如下代码`initialCount`，只会在组件初始化时赋值给`count`，后续如果要修改`count`，需要通过`setCount`来进行修改，这和`this.setState`的使用方式也是一样的

```jsx
const [count, setCount] = useState(initialCount);
```

如果你在初始化`useState`，需要进行计算，可以使用如下方式

```jsx
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

**注意**

1. 与 class 组件中的 `setState` 方法不同的是`useState` 不会自动合并更新对象。所以需要将一个完整的对象传递给`useState` 

```jsx
// class
this.state={
    name:'smw',
    age:18
}
this.setState({
    age:20
})

// hooks
const [state, setState] = useState({
    name:'smw',
    age:18
})
setState(preState=>{
    return {
        ...preState,
        age:20
    }
})
```

2. 在调用`setState`时，会将新老设置的值进行 [Object.is 比较算法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description) 。所以需要使用展开运算符或者`Object.assign`来声明新值。

```jsx
// 错误写法
const [state, setState] = useState({
    name: 'smw',
    age: 18,
})

  setState((preState) => {
        preState.age = 20
        return preState
    })

// 正确写法
setState((preState) => {
    return {
        ...preState,
        age:20
    }
})
```

ps：但是上述的操作其实并不够优雅，并且当你可能只是需要修改数组中的某个值，甚至你操作的数据是`Set`或者`Map`类型的，那处理起来就更复杂了。所以可能你需要[immerjs](https://github.com/immerjs/immer)来帮助你。



### 实现getDerivedStateFromProps

在使用`hooks`时，我们可以这样实现`getDerivedStateFromProps`

例如：当父组件传递过来的`userId`发生变化时，我们需要重新获取`userInfo`，来更新视图。

```jsx
function UserInfo({ userId }) {
  const [userInfo, setUserInfo] = useState(() => {
  const userInfo = getUserInfoByUserId(userId)
    setPrevUserId(userInfo)
  })
  const [prevUserId, setPrevUserId] = useState(userId)

  if (userId !== prevUserId) {
    // 获取新的userId，去获取数据
    const userInfo = getUserInfoByUserId(userId)
    setPrevUserId(userId)
  }

  return (
    <div>
      <p>userName:{userInfo.userName}</p>
    </div>
  )
}
```

以上是官方推荐的实现方法，但是你要单独创建一个`state`用来保存`preProps`，如果你只需要监听变化，而不要用到`preProps`，个人认为以下方式实现起来更简单明了，`useEffect`在初始化的时候会执行一次，同时当`userId`发生变化也会触发。满足`getDerivedStateFromProps`的触发规则。

```jsx
const UserInfo = ({ userId }) => {
  const [userInfo, setUserInfo] = useState({})

  useEffect(() => {
    const userInfo = userInfoMap[userId]
    setUserInfo(userInfo)
  }, [userId])
  
  return (
    <div>
      <p>name : {userInfo.userName}</p>
    </div>
  )
}
```



### 实现shouldComponentUpdate

可以用 `React.memo` 包裹一个组件来对它的 props 进行浅比较

- 等效于`PureComponent`，但是只比较 `props`
- 自定义`props`比较逻辑

```jsx
const MemoChild = React.memo(Child, (prevProps, nextProps) => {
  // 比较prevProps和nextProps
  // 返回true则不更新
  return true
})
```

- `React.memo` 不比较 state，因为没有单一的 state 对象可供比较。但你也可以让子节点变为纯组件，或者 [用 `useMemo` 优化每一个具体的子节点](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations)。



### useRef、useImperativeHandle

- `useRef`：在`Function`组件中，获取子组件`ref`

- `useImperativeHandle`：在`Function`组件中，定义可被父组件获取到的`ref`

**useRef**

无论是获取`Function`组件、`class`组件还是真实`dom`，方法都是一样的

```jsx
const Index = () => {
  const fnChildEl = useRef(null)
  const inputEl = useRef(null)
  const classChildEl = useRef(null)

  useEffect(() => {
    console.log('fnChildEl', fnChildEl)
    console.log('inputEl', inputEl)
    console.log('classChildEl', classChildEl)
  }, [])

  return (
    <div>
      <input ref={inputEl} type="text" />
      <FnChild  ref={fnChildEl}/>
      <ClassChild ref={classChildEl} />
    </div>
  )
}
```

在`Function`组件中，使用[callback ref](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#callback-refs)的方式使用子组件的`ref`

一般什么情况下会使用这种方式来调用`ref`

例如：子组件中需要暴露`ref`，存在延迟加载的情况，就需要使用这种方式。`useRef`会在组件初始化时就获取`ref`，但是初始化时，可能子组件需要暴露`ref`的节点还没有被渲染。具体demo可以查看：[demo](https://codesandbox.io/s/quizzical-jepsen-od1xc?file=/src/index.js:745-749)

```jsx
function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    <>
      <h1 ref={measuredRef}>Hello, world</h1>
      <h2>The above header is {Math.round(height)}px tall</h2>
    </>
  );
}
```

**useImperativeHandle**

在`Function`组件中，暴露`ref`给父组件使用

由于`Function`组件没有实例，所以要使用`useImperativeHandle`，声明自生的`ref`。声明了以后就可以使用`useRef`获取到`Function`子组件的`ref`

```jsx
function FnChild(props, ref) {
  const inputRef = useRef()
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus()
    },
  }))

  return <input ref={inputRef} type="text" />
}
FnChild = forwardRef(FnChild)
```



### useEffect

`useEffect`会使函数延迟执行，也就是说`React` 会等待浏览器完成画面渲染之后才会延迟调用 `useEffect`

执行的特点：

- 执行的时机在dom渲染之后
- 通过`requestIdleCallback`异步执行

**具体使用方式**

只在初始化时执行一次，通过第二个参数传入空数组实现
可以实现`componentDidMount`的调用

```jsx
useEffect(() => {
    // code
}, [])
```

在初始化时执行一次，当`props.test`发生变化时会继续触发
可以实现`componentDidUpdate`的调用
如果要获取pre参数，可以参考[实现getDerivedStateFromProp章节](#实现-getderivedstatefromprops)

```jsx
useEffect(() => {
    // code
}, [props.test])
```

在`useEffect`返回一个函数可以实现`componentWillUnmount`

```jsx
useEffect(() => {
    // code
    return () => {
        // code
    }
}, [])
```

ps：与 `componentDidMount`、`componentDidUpdate` 不同的是，在浏览器完成布局与绘制**之后**，传给 `useEffect` 的函数会延迟调用。想了解关于`useEffect`的更多使用细节可查看[官方文件说明](https://zh-hans.reactjs.org/docs/hooks-faq.html#performance-optimizations)



### useLayoutEffect

其使用方式与`useEffect`相同，区别只是调用时机不同。

不同点是：

- 执行的时机在`dom`渲染之前
- 同步执行，会阻塞`dom`的渲染

官方示例：例如，在浏览器执行下一次绘制前，用户可见的 DOM 变更就必须同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）

个人理解：如果`dom`的渲染依赖某些初始化的计算，`useLayoutEffect`可以规避掉，使用`useEffect`异步计算然后更新`dom`造成的页面抖动的情况。



