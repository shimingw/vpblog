---
title: "React-hooks入坑指南"
date: 2020-09-01
category: React
permalink: "2020-09-01-React-ReactHooks入坑指南"
---

## 前言

如果你是在使用`React >= 16.8`的版本，那么你可以使用`hooks`在编写你的组件，它可以让你在不编写 `class` 的情况下使用 `state` 以及其他的 `React` 特性。



## 为什么要使用Hooks

1. 提供代码逻辑复用的另一种选择（[自定义 Hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)），其他选择[Render Props](https://zh-hans.reactjs.org/docs/render-props.html)、[HOC](https://zh-hans.reactjs.org/docs/higher-order-components.html)、[mixins（不推荐使用）](https://zh-hans.reactjs.org/docs/react-without-es6.html#mixins)
2. 没有了class复杂的生命周期，组件写起来更清爽。
3. 官方推荐使用，后续官网应该会不断完善`Hooks`



## HooksApi

### useState

通常我们在使用class组件时，会在`constructor`中初始化`state`。`constructor`只会在组件实例化时执行一次。同样的，使用`useState`可以实现上述的操作。

如下代码`initialCount`，只会在组件初始化时赋值给`count`，后续如果要修改`count`，需要通过`setCount`来进行修改，这和`this.setState`的使用方式也是一样的

```jsx
const [count, setCount] = useState(initialCount);
```

如果你在初始化`useState`，需要进行计算，可以使用如下方式

```jsx
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

**注意**

1. 与 class 组件中的 `setState` 方法不同的是`useState` 不会自动合并更新对象。所以需要将一个完整的对象传递给`useState` 

```jsx
// class
this.state={
    name:'smw',
    age:18
}
this.setState({
    age:20
})

// hooks
const [state, setState] = useState({
    name:'smw',
    age:18
})
setState(preState=>{
    return {
        ...preState,
        age:20
    }
})
```

2. 在调用`setState`时，会将新老设置的值进行 [Object.is 比较算法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description) 。所以需要使用展开运算符或者`Object.assign`来声明新值。

```jsx
// 错误写法
const [state, setState] = useState({
    name: 'smw',
    age: 18,
})

  setState((preState) => {
        preState.age = 20
        return preState
    })

// 正确写法
setState((preState) => {
    return {
        ...preState,
        age:20
    }
})
```



### 实现getDerivedStateFromProps

在使用`hooks`时，我们可以这样实现`getDerivedStateFromProps`

例如：当父组件传递过来的`userId`发生变化时，我们需要重新获取`userInfo`，来更新视图。

```jsx
function UserInfo({ userId }) {
  const [userInfo, setUserInfo] = useState(() => {
  const userInfo = getUserInfoByUserId(userId)
    setPrevUserId(userInfo)
  })
  const [prevUserId, setPrevUserId] = useState(userId)

  if (userId !== prevUserId) {
    // 获取新的userId，去获取数据
    const userInfo = getUserInfoByUserId(userId)
    setPrevUserId(userId)
  }

  return (
    <div>
      <p>userName:{userInfo.userName}</p>
    </div>
  )
}
```

以上是官方推荐的实现方法，但是你要单独创建一个`state`用来保存`preProps`，略显累赘，个人认为以下方式实现起来更简单明了，`useEffect`在初始化的时候会执行一次，同时当`userId`发生变化也会触发。满足`getDerivedStateFromProps`的触发规则。

```jsx
const UserInfo = ({ userId }) => {
  const [userInfo, setUserInfo] = useState({})

  useEffect(() => {
    const userInfo = userInfoMap[userId]
    setUserInfo(userInfo)
  }, [userId])
  
  return (
    <div>
      <p>name : {userInfo.userName}</p>
    </div>
  )
}
```



### 实现shouldComponentUpdate



### 实现ref

在`Function`组件中，获取子组件的`ref`

无论是获取`Function`组件、`class`组件还是真实`dom`，方法都是一样的

```jsx
const Index = () => {
  const fnChildEl = useRef(null)
  const inputEl = useRef(null)
  const classChildEl = useRef(null)

  useEffect(() => {
    console.log('fnChildEl', fnChildEl)
    console.log('inputEl', inputEl)
    console.log('classChildEl', classChildEl)
  }, [])

  return (
    <div>
      <input ref={inputEl} type="text" />
      <FnChild  ref={fnChildEl}/>
      <ClassChild ref={classChildEl} />
    </div>
  )
}
```

在`Function`组件中，使用[callback ref](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#callback-refs)的方式使用子组件的`ref`

一般什么情况下会使用这种方式来调用`ref`

例如：子组件中需要暴露`ref`，存在延迟加载的情况，就需要使用这种方式。`useRef`会在组件初始化时就获取`ref`，但是初始化时，可能子组件需要暴露`ref`的节点还没有被渲染。具体demo可以查看：[demo](https://codesandbox.io/s/quizzical-jepsen-od1xc?file=/src/index.js:745-749)

```jsx
function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    <>
      <h1 ref={measuredRef}>Hello, world</h1>
      <h2>The above header is {Math.round(height)}px tall</h2>
    </>
  );
}
```

在`Function`组件中，暴露`ref`给父组件使用

由于`Function`组件没有实例，所以要使用`useImperativeHandle`，声明自生的`ref`。声明了以后就可以使用`useRef`获取到`Function`子组件的`ref`

```jsx
function FnChild(props, ref) {
  const inputRef = useRef()
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus()
    },
  }))

  return <input ref={inputRef} type="text" />
}
FnChild = forwardRef(FnChild)
```

