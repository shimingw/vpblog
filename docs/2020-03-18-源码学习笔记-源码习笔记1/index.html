<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>源码习笔记1 | 嘻哈工程师</title>
    <meta name="description" content="嘻哈工程师的博客">
    <meta name="generator" content="VuePress 1.4.0">
    <script type="text/javascript" src="/baidu-analytics.js" async="async"></script>
  <link rel="icon" href="/icons/favicon.ico">
  <meta name="referrer" content="no-referrer">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" sizes="192x192" href="/icons/192.png">
  <meta name="msapplication-TileImage" content="/icons/144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.cb726fc1.css" as="style"><link rel="preload" href="/assets/js/app.750d9439.js" as="script"><link rel="preload" href="/assets/js/2.8423ab85.js" as="script"><link rel="preload" href="/assets/js/66.c587177b.js" as="script"><link rel="preload" href="/assets/js/5.d4f27e5e.js" as="script"><link rel="prefetch" href="/assets/js/10.5f24d8df.js"><link rel="prefetch" href="/assets/js/11.0dfb1802.js"><link rel="prefetch" href="/assets/js/12.8d643611.js"><link rel="prefetch" href="/assets/js/13.73b840fa.js"><link rel="prefetch" href="/assets/js/14.bdb8c56d.js"><link rel="prefetch" href="/assets/js/15.babc1c19.js"><link rel="prefetch" href="/assets/js/16.22262991.js"><link rel="prefetch" href="/assets/js/17.c5df7b0d.js"><link rel="prefetch" href="/assets/js/18.671b2319.js"><link rel="prefetch" href="/assets/js/19.1cd327f2.js"><link rel="prefetch" href="/assets/js/20.5acad778.js"><link rel="prefetch" href="/assets/js/21.56688797.js"><link rel="prefetch" href="/assets/js/22.e311e43f.js"><link rel="prefetch" href="/assets/js/23.09f2c50d.js"><link rel="prefetch" href="/assets/js/24.40fc4b93.js"><link rel="prefetch" href="/assets/js/25.33ad19ba.js"><link rel="prefetch" href="/assets/js/26.befdf62a.js"><link rel="prefetch" href="/assets/js/27.ba30a901.js"><link rel="prefetch" href="/assets/js/28.c7ff221a.js"><link rel="prefetch" href="/assets/js/29.da813cd5.js"><link rel="prefetch" href="/assets/js/3.0eab7565.js"><link rel="prefetch" href="/assets/js/30.222ad28f.js"><link rel="prefetch" href="/assets/js/31.e2bb721b.js"><link rel="prefetch" href="/assets/js/32.f6bee87d.js"><link rel="prefetch" href="/assets/js/33.0e45d3d6.js"><link rel="prefetch" href="/assets/js/34.20172422.js"><link rel="prefetch" href="/assets/js/35.eeff9ddc.js"><link rel="prefetch" href="/assets/js/36.4a78aa1a.js"><link rel="prefetch" href="/assets/js/37.42b97312.js"><link rel="prefetch" href="/assets/js/38.3f9cdd23.js"><link rel="prefetch" href="/assets/js/39.71d8e3ff.js"><link rel="prefetch" href="/assets/js/4.3fcff089.js"><link rel="prefetch" href="/assets/js/40.5cc9e86c.js"><link rel="prefetch" href="/assets/js/41.8c6d8278.js"><link rel="prefetch" href="/assets/js/42.862b3fe7.js"><link rel="prefetch" href="/assets/js/43.abbcf4bc.js"><link rel="prefetch" href="/assets/js/44.86c78d9c.js"><link rel="prefetch" href="/assets/js/45.96282dcf.js"><link rel="prefetch" href="/assets/js/46.31b43110.js"><link rel="prefetch" href="/assets/js/47.5c4b3bc7.js"><link rel="prefetch" href="/assets/js/48.966a2bee.js"><link rel="prefetch" href="/assets/js/49.f6df68e3.js"><link rel="prefetch" href="/assets/js/50.de627bac.js"><link rel="prefetch" href="/assets/js/51.7123abef.js"><link rel="prefetch" href="/assets/js/52.acfa40fc.js"><link rel="prefetch" href="/assets/js/53.32ffb13a.js"><link rel="prefetch" href="/assets/js/54.04fe2431.js"><link rel="prefetch" href="/assets/js/55.345fb432.js"><link rel="prefetch" href="/assets/js/56.e3d536f2.js"><link rel="prefetch" href="/assets/js/57.ff902575.js"><link rel="prefetch" href="/assets/js/58.7fb5f09a.js"><link rel="prefetch" href="/assets/js/59.1b79b37c.js"><link rel="prefetch" href="/assets/js/6.60f95b97.js"><link rel="prefetch" href="/assets/js/60.b8d3b240.js"><link rel="prefetch" href="/assets/js/61.6972e7b9.js"><link rel="prefetch" href="/assets/js/62.70420cc2.js"><link rel="prefetch" href="/assets/js/63.33b52044.js"><link rel="prefetch" href="/assets/js/64.37357140.js"><link rel="prefetch" href="/assets/js/65.bd1c6701.js"><link rel="prefetch" href="/assets/js/67.64b2ae84.js"><link rel="prefetch" href="/assets/js/68.6f9bb6ac.js"><link rel="prefetch" href="/assets/js/69.ae7d864c.js"><link rel="prefetch" href="/assets/js/7.ed32b398.js"><link rel="prefetch" href="/assets/js/70.60dcb915.js"><link rel="prefetch" href="/assets/js/71.93debbad.js"><link rel="prefetch" href="/assets/js/72.301f9314.js"><link rel="prefetch" href="/assets/js/73.4717c3a6.js"><link rel="prefetch" href="/assets/js/8.63fa3eff.js"><link rel="prefetch" href="/assets/js/9.1237af06.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cb726fc1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">嘻哈工程师</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  最新
</a></div><div class="nav-item"><a href="/archives/" class="nav-link">
  归档
</a></div> <a href="https://github.com/shimingw/vpblog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  最新
</a></div><div class="nav-item"><a href="/archives/" class="nav-link">
  归档
</a></div> <a href="https://github.com/shimingw/vpblog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/" class="active sidebar-link">源码习笔记1</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#node" class="sidebar-link">Node</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#第二课" class="sidebar-link">第二课</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#第四课" class="sidebar-link">第四课</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#第五课" class="sidebar-link">第五课</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#第六课" class="sidebar-link">第六课</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#第七课" class="sidebar-link">第七课</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#第八课" class="sidebar-link">第八课</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#第九课" class="sidebar-link">第九课</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#第十课" class="sidebar-link">第十课</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#项目实战" class="sidebar-link">项目实战</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#react" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#简要介绍" class="sidebar-link">简要介绍</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#组件通信" class="sidebar-link">组件通信</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#_16-4版本之后废弃的生命周期函数" class="sidebar-link">16.4版本之后废弃的生命周期函数</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#引入了两个新的生命周期函数" class="sidebar-link">引入了两个新的生命周期函数</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#组件跨层级通信-context" class="sidebar-link">组件跨层级通信 context</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#组件复合-composition" class="sidebar-link">组件复合-Composition</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#高阶组件-hoc" class="sidebar-link">高阶组件 HOC</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#hooks" class="sidebar-link">Hooks</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#antd-form" class="sidebar-link">antd-form</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#createportal" class="sidebar-link">createPortal</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#purecomponent" class="sidebar-link">pureComponent</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#redux" class="sidebar-link">redux</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#react-redux" class="sidebar-link">react-redux</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#react-route" class="sidebar-link">react-route</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#redux-thunk、redux-saga" class="sidebar-link">redux-thunk、redux-saga</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#react-源码" class="sidebar-link">react 源码</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#setstate" class="sidebar-link">setState</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#domdiff" class="sidebar-link">domdiff</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#react-的-fiber-架构" class="sidebar-link">react 的 fiber 架构</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#网络安全（攻击手段）" class="sidebar-link">网络安全（攻击手段）</a></li><li class="sidebar-sub-header"><a href="/docs/2020-03-18-源码学习笔记-源码习笔记1/#网络安全（防御手段）" class="sidebar-link">网络安全（防御手段）</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="node"><a href="#node" class="header-anchor">#</a> Node</h2> <h3 id="第二课"><a href="#第二课" class="header-anchor">#</a> 第二课</h3> <ul><li>跨域（同源策略）
<ul><li><strong>非简单请求</strong>前会触发<strong>预检</strong>（INPUT 请求）</li> <li>后端在请求头中，设置允许请求的源</li> <li>反向代理可以解决跨域请求
<ul><li>反向代理是服务器端</li> <li>正向代理是在客户端</li></ul></li></ul></li></ul> <h3 id="第四课"><a href="#第四课" class="header-anchor">#</a> 第四课</h3> <ul><li>mysql
<ul><li>关系型数据库</li> <li>通常使用<code>ORM</code>去操作数据库</li> <li>主键推荐使用<code>UUID</code>（不使用自增<code>id</code>），这样在以后分库分表的时候不会产生冲突</li> <li>利用<code>ORM</code>可以建立数据库表中的对应关系。一对一，一对多，多对多</li></ul></li></ul> <h3 id="第五课"><a href="#第五课" class="header-anchor">#</a> 第五课</h3> <ul><li><p>MongoDB</p> <ul><li>非关系型数据库</li> <li>适合便捷开发</li></ul></li> <li><p>Mongoose</p> <ul><li>mgdb 的中间件</li> <li>ODM</li> <li>存在的价值：实体驱动设计
<ul><li>代码中定义实体字段</li> <li>向下自动生成表</li> <li>向上提供 ORM 操作</li></ul></li></ul></li></ul> <h3 id="第六课"><a href="#第六课" class="header-anchor">#</a> 第六课</h3> <p>鉴权</p> <ul><li><code>session</code>/<code>cookie</code> <ul><li>用户数据存在后端</li></ul></li> <li>JWT
<ul><li>JSON WEB TOKEN</li> <li>包含三部分：令牌头、payload、哈希</li></ul></li> <li>OAuth（以<code>github</code>为例）
<ul><li>带上<code>client_id</code>重定向到<code>github</code>登录页</li> <li>用户输入账号密码登录</li> <li>登录后<code>github</code>回带着<code>code</code>，重定向到服务器的页面</li> <li>服务器用<code>code</code>再向<code>github</code>发起请求，获取用户的<code>access_token</code></li> <li>获取到<code>access_token</code>后，服务器拿着<code>access_token</code>，就可以获取到用户的信息</li> <li>后面服务器可以将<code>access_token</code>，数据持久化，下次登录，直接向<code>github</code>请求获取用户信息</li></ul></li> <li>SSO（单点登录）
<ul><li>同域下的单点登录
<ul><li>通过共享<code>cookie</code>来实现单点登录</li> <li>需要将多个应用登录信息保存在一个<code>session</code>中</li></ul></li> <li>不同域下的单点登录
<ul><li>通过一个 SSO 中间平台</li> <li>每个服务，登录时，都会重定向到 SSO 平台</li> <li>SSO 验证自己是否已经登陆过</li> <li>如果登录过，则带着<code>ticket</code>，重定向到改服务</li> <li>服务器拿着<code>ticket</code>去验证是否有效，</li> <li>如果有效，则返回用户信息。并将用户信息保存在<code>session</code>中</li> <li>如果无效则重新登录，获取新的<code>ticket</code></li> <li>当然也可以将<code>session</code>通过<code>redis</code>等服务器实现共享</li></ul></li></ul></li></ul> <h3 id="第七课"><a href="#第七课" class="header-anchor">#</a> 第七课</h3> <p>egg</p> <ul><li>egg 分为三层
<ul><li>control：控制器（信息资源层），去调用 serivce 层</li> <li>model：数据绑定层，提供查询数据的 api</li> <li>service：业务逻辑处理层</li></ul></li> <li>egg 实现原理
<ul><li>egg 是基于 koa 实现的一套企业级框架</li> <li>通过初始化 egg 时</li> <li>导入路由模块文件</li> <li>导入控制器模块文件</li> <li>导入 service 层模块文件</li> <li>导入 model 层模块文件</li> <li>约定文件所属目录，文件名称等一系列的方式来约定</li></ul></li> <li>定时任务
<ul><li>使用 node-schedule 来管理定时任务</li></ul></li></ul> <h3 id="第八课"><a href="#第八课" class="header-anchor">#</a> 第八课</h3> <p>egg 最佳实践</p> <ul><li><p>基于插件的 swagger-doc 接口定义</p></li> <li><p>统一异常处理</p></li> <li><p>基于拓展的 hepler 响应统一处理</p></li> <li><p>validate 接口格式检查</p></li> <li><p>三层结构</p> <ul><li>control 层</li> <li>service 层</li> <li>model 层</li></ul></li> <li><p>jwt 统一鉴权</p> <ul><li>根据接口前缀进行鉴权</li></ul></li> <li><p>文件上传</p></li></ul> <h3 id="第九课"><a href="#第九课" class="header-anchor">#</a> 第九课</h3> <p>ts 与装饰器</p> <ul><li>类 Class</li> <li>接口 Interface</li> <li>模块 Module</li> <li>类型注解</li> <li>装饰器
<ul><li>类装饰</li> <li>方法装饰</li> <li>AOP 功能</li></ul></li> <li>编译时的类型检查</li> <li>箭头函数</li></ul> <h3 id="第十课"><a href="#第十课" class="header-anchor">#</a> 第十课</h3> <p>费曼学习法</p> <h4 id="node-部署"><a href="#node-部署" class="header-anchor">#</a> node 部署</h4> <p>主要解决问题</p> <ul><li>故障恢复、多核利用</li></ul> <p>使用<code>cluster</code>这个<code>node</code>自带的库可以解决故障恢复和多核利用</p> <p><strong>实现思路</strong></p> <p>多核利用：将主进程<code>fork</code>多份，主进程启动服务后，<code>fork</code>的进程也会启动一样的服务</p> <p>故障恢复：<code>cluster</code>可以监听，子进程的状态，如果发现子进程挂了，就重启该子进车</p> <p>ps：也可以使用 pm2 去实现上述功能</p> <ul><li>多进程共享端口</li></ul> <h4 id="docker"><a href="#docker" class="header-anchor">#</a> docker</h4> <ul><li>操作系统层面的虚拟化技术</li> <li>隔离的进程独立于宿主和其他的隔离的进程-容器</li> <li>go 语言发</li></ul> <p>特点</p> <ul><li>高效利用系统资源</li> <li>快速启动</li> <li>更轻松的迁移</li></ul> <p><strong>定制镜像</strong></p> <ol><li>定制一个 nginx 镜像</li></ol> <p>编写配置文件（Dockerfile）</p> <p>docker build -t &lt;镜像名称&gt; Dockerfile</p> <div class="language-dockerfile extra-class"><pre class="language-dockerfile"><code><span class="token comment">#Dockerfile</span>
<span class="token keyword">FROM</span> nginx<span class="token punctuation">:</span>latest
<span class="token keyword">RUN</span> echo ‘hello docker’ <span class="token punctuation">&gt;</span> /usr/share/nginx/html/index.html
</code></pre></div><ol start="2"><li>定制一个 node 镜像</li></ol> <div class="language-dockerfile extra-class"><pre class="language-dockerfile"><code><span class="token comment">#定制node镜像版本</span>
<span class="token keyword">FROM</span> node<span class="token punctuation">:</span>10<span class="token punctuation">-</span>alpine
<span class="token comment">#移动当前目录下的文件到app目录下，即将node项目拷贝到app目录</span>
<span class="token keyword">ADD</span> . /app/
<span class="token comment">#进入到app目录下面，类似cd</span>
<span class="token keyword">WORKDIR</span> /app
<span class="token comment">#安装依赖</span>
<span class="token keyword">RUN</span> npm install
<span class="token comment">#对外暴露的端口</span>
<span class="token keyword">EXPOSE</span> 3000
<span class="token comment">#程序启动脚本</span>
<span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;app.js&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p><strong>一次性操作多个<code>docker</code></strong></p> <blockquote><p>使用 Docker-Compose 命令</p></blockquote> <ol><li>配置 docker-compose.yml 文件，在文件中写入多个 docker 的配置</li> <li>使用 <code>docker-compose up</code> 命令。启动多个 docker 服务</li></ol> <p>https://github.com/su37josephxia/docker_ci</p> <h2 id="项目实战"><a href="#项目实战" class="header-anchor">#</a> 项目实战</h2> <p>错误收集方案</p> <ol><li>全局捕获，使用<code>window.onerror</code>（通过 img 标签来发请求）</li> <li>主动上报。try/catch</li> <li>sentry（免费够用）</li> <li>fundebug（收费、国内做的比较好的）</li> <li>自己手写报错平台</li> <li>错误通知机制</li></ol> <p>数据库设计</p> <ul><li>一对多</li> <li>多对多</li></ul> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <h3 id="简要介绍"><a href="#简要介绍" class="header-anchor">#</a> 简要介绍</h3> <ol><li><p><code>React</code>负责逻辑控制，将数据转化成<code>VNode</code>（主要功能<code>React.createElement</code>）</p></li> <li><p><code>ReactDom</code>渲染实际<code>DOM</code>，将<code>VNode</code>转化成真实<code>DOM</code></p></li> <li><p>组件形式有两种</p></li></ol> <ul><li><code>function</code>组件</li> <li><code>class</code>组件</li></ul> <ol start="4"><li><p>vscode 中 react 插件 auto-import</p></li> <li><p>this.state 的执行时异步，如果要实现同步可以</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第一种</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">nextState</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    retrun <span class="token punctuation">{</span>
        count<span class="token operator">:</span><span class="token operator">++</span>nextState<span class="token punctuation">.</span>count
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 第二种</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        count<span class="token operator">:</span><span class="token operator">++</span>nextState<span class="token punctuation">.</span>count
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment">//第三种</span>
<span class="token comment">//使用原生事件绑定的方式</span>
<span class="token function">addEventLister</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        count<span class="token operator">:</span><span class="token operator">++</span>nextState<span class="token punctuation">.</span>count
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h3> <ul><li><code>props</code>父子组件之间传值</li> <li><code>context</code>跨层级组件组件通信</li> <li><code>redux</code>类似<code>vuex</code>，无明显关系的组件通信</li></ul> <h3 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h3> <ul><li><p><img src="https://upload-images.jianshu.io/upload_images/10306662-b1113e690ef13a8d.png" alt=""></p></li> <li><p><code>componentWillMount</code>组件挂载之前</p></li> <li><p><code>render</code>组件挂载方法</p></li> <li><p><code>componentDidMount</code>组件挂载之后</p></li> <li><p><code>componentWillReceiveProps 已挂载的组件的</code>props 传值发生变化时触发</p></li> <li><p><code>shouldComponentUpdate</code>组件更新之前，在<code>componentWillUpdate</code>之前，决定组件是否更新</p></li> <li><p><code>componentWillUpdate</code>组件更新之前</p></li> <li><p><code>componentDidUpdate</code>组件更新之后</p></li> <li><p><code>componentWillUnmount</code>组件卸载之前</p></li></ul> <h3 id="_16-4版本之后废弃的生命周期函数"><a href="#_16-4版本之后废弃的生命周期函数" class="header-anchor">#</a> <strong>16.4</strong>版本之后废弃的生命周期函数</h3> <p><img src="https://upload-images.jianshu.io/upload_images/12185313-85b3010f0b8b7d16.png" alt=""></p> <ul><li><p>如果一定要使用需要加 UNSAFE</p></li> <li><p><code>componentWillMount</code></p></li> <li><p><code>componentWillReceiveProps</code></p></li> <li><p><code>componentWillUpdate</code></p></li></ul> <h3 id="引入了两个新的生命周期函数"><a href="#引入了两个新的生命周期函数" class="header-anchor">#</a> 引入了两个新的生命周期函数</h3> <ul><li><code>Static getDerivedStateFromProps</code>当 props 传值发生变化时触发
<ul><li>在初始挂载及后续更新时都会被调用</li> <li>返回的对象会被当做<code>this.setState</code>的参数进行设置</li> <li>返回<code>null</code>则，不触发</li></ul></li> <li><code>getSanapshotBeforeUpdate</code>组件 update 时获取上一次的<code>props</code>和<code>state</code></li></ul> <h3 id="组件跨层级通信-context"><a href="#组件跨层级通信-context" class="header-anchor">#</a> 组件跨层级通信 context</h3> <p>版本&gt;=16.3</p> <p>类似<code>vue</code>的<code>provide</code>和<code>inject</code></p> <p>写组件库的时候经常会用到</p> <ul><li><code>Provider</code>:提供者</li> <li><code>Consumer</code>：消费者</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React from 'react'
// 在这里创建提供者，可以使用别名去区分
const Context = React.createContext('text')
const Provider = Context.Provider
const Consumer = Context.Consumer
const store = {
  user: {
    name: 'shimingw'
  }
}
function App() {
  retrun(
    &lt;div&gt;
      &lt;Provider value={store}&gt;
        {/* 在哪里需要使用的时候再把 Consumer 引进来*/}
        &lt;Consumer&gt;{ctx =&gt; &lt;Home {...ctx} /&gt;}&lt;/Consumer&gt;
      &lt;/Provider&gt;
    &lt;/div&gt;
  )
}

function Home(props) {
  // 这里通过props就可以父组件传递的值
  // 或者也可以直接使用this.context
  return &lt;div&gt;home&lt;/div&gt;
}
</code></pre></div><h3 id="组件复合-composition"><a href="#组件复合-composition" class="header-anchor">#</a> 组件复合-Composition</h3> <p>类似<code>vue</code>的<code>slot</code>功能，也有<strong>具名插槽</strong>和<strong>默认插槽</strong>两种</p> <p>通过<code>this.props.children</code>来获取嵌套子组件</p> <h3 id="高阶组件-hoc"><a href="#高阶组件-hoc" class="header-anchor">#</a> 高阶组件 HOC</h3> <p>他是一个工厂函数</p> <p>将组件以传值的方式传进来，他接收一个组件并返回另一个组件</p> <p>也可以使用装饰器写法，更优雅</p> <div class="language-react extra-class"><pre class="language-text"><code>const consumerHandle = Cmp =&gt; props =&gt; {
  return &lt;Consumer&gt;{ctx =&gt; &lt;Cmp {...props} {...ctx} /&gt;}&lt;/Consumer&gt;
}
</code></pre></div><h3 id="hooks"><a href="#hooks" class="header-anchor">#</a> Hooks</h3> <p>版本&gt;=16.8</p> <p>可以时函数时组件，具备状态</p> <ul><li><code>useState</code>管理组件状态</li> <li><code>useEffect</code>副作用，可作为声明周期使用</li> <li><code>useReducer</code>一个进阶版的<code>useState</code>，可执行多重状态更新的动作</li> <li><code>useContext</code>快速在函数组件中导入上下文</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState, useEffect, useReducer } from 'react'

function fruitsReducer(state, action) {
  // state初始化时传入的值
  // action更新动作
  switch (action.type) {
    case 'init':
      return action.payload
    default:
      return state
  }
}

function Hooks() {
  const [count, setCount] = useState(0)
  const [fruites, dispatch] = useState(fruitsReducer, [])
  useEffect(() =&gt; {
    // 第二参数为数据，可以监听组件state中的值
    // 如果不传值。则未作函数挂在前执行的方法

    // setCount后会更新count的值
    setCount(1)
    // dispatch后会更新fruites
    dispatch({ type: 'init', payload: ['apple'] })
    // return的函数在组件卸载前会执行
    return () =&gt; {}
  })
  return (
    &lt;div&gt;
      {count}
      {fruites}
    &lt;/div&gt;
  )
}
</code></pre></div><h3 id="antd-form"><a href="#antd-form" class="header-anchor">#</a> antd-form</h3> <p><code>React.cloneElement(&lt;ReactCmp&gt;,options)</code></p> <p>手写<code>antd</code>的<code>form</code>表单</p> <h3 id="createportal"><a href="#createportal" class="header-anchor">#</a> createPortal</h3> <p>可将组件渲染至任意节点（传送门）</p> <p>接受两个参数，一个数组件，第二是需要渲染到的父节点</p> <h3 id="purecomponent"><a href="#purecomponent" class="header-anchor">#</a> pureComponent</h3> <p>会比较组件数据更新前后的数据，如果没有变化则不重新<code>render</code>组件</p> <p>但是仅支持浅比较。如果是嵌套对象，则需要使用<code>shouldUpdate</code></p> <h3 id="redux"><a href="#redux" class="header-anchor">#</a> redux</h3> <p>实现原理是基于发布订阅</p> <ul><li><code>createStore</code> 创建<code>store</code></li> <li><code>reducer</code> 接受一个旧的<code>state</code>和<code>action</code>返回一个新的<code>state</code>来更新组件</li> <li><code>getState</code> 获取状态值</li> <li><code>dispatch</code> 提交更新，触发某个<code>reducer</code></li> <li><code>subscribe</code> 订阅某个<code>reducer</code></li></ul> <h3 id="react-redux"><a href="#react-redux" class="header-anchor">#</a> react-redux</h3> <p>实现原理是<code>redux</code>+<code>context</code>来实现<code>react</code>专用的<code>redux</code></p> <ul><li><code>provider</code> 为后代组件提供<code>store</code></li> <li><code>connect</code> 为组件提供数据和变更方法</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>connect(state=&gt;{
	return {value:state}
},{
	add:()=&gt;{
		return{
			type:'add'
		}
	}
}
)(&lt;Cmp /&gt;)
</code></pre></div><h3 id="react-route"><a href="#react-route" class="header-anchor">#</a> react-route</h3> <p>奉行一切皆组件的思想</p> <p>实现原理：借助<code>history</code>这个库来实现路由跳转，<code>context</code>来跨组件传值，在<code>Route</code>组件中，使用<code>React.createElement</code>来渲染对应的组件</p> <ul><li><code>BrowserRouter</code>最外层组件</li> <li><code>Link</code>路由跳转链接</li> <li><code>Route</code>路由匹配组件</li> <li><code>Switch</code>独占路由</li></ul> <h4 id="路由守卫"><a href="#路由守卫" class="header-anchor">#</a> 路由守卫</h4> <p>以前<code>react</code>可以和<code>vue</code>一样，有路由的生命周期来做路由守卫，但是从 4.0 版本开始，把这个钩子删了，作者的理由是：删了更自由。现在就采用高阶组件的形式来体现了</p> <h3 id="redux-thunk、redux-saga"><a href="#redux-thunk、redux-saga" class="header-anchor">#</a> redux-thunk、redux-saga</h3> <p><code>react-redux</code>的两个异步处理方案</p> <h4 id=""><a href="#" class="header-anchor">#</a></h4> <h3 id="react-源码"><a href="#react-源码" class="header-anchor">#</a> react 源码</h3> <p><code>reactCreateElement</code>将传入的<code>vnode</code>递归解析，分为纯文本节点、<code>class</code>组件、<code>function</code>组件。然后使用<code>appendChild</code>将节点挂在到<code>dom</code>节点上</p> <h3 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h3> <p>只有在 react 合成事件和生命周期函数中是异步的，在原生事件和<code>setTimeout</code>、<code>setInterval</code>、<code>addEventListener</code>中是同步的</p> <p>原生事件绑定不会通过合成事件的处理方式，所以不会进入更新事务的处理流程。<code>setTimeout</code>，在回调执行时已经完成了原更新组件的流程，也不会再进入异步更新流程，所以是同步</p> <ol><li><code>setState</code>执行时，<code>updater</code>会将<code>partialState</code>添加带他维护的<code>pendingStates</code>中</li> <li><code>updateComponent</code>负责合并<code>pendingStates</code>中所有的<code>state</code>变成一个<code>state</code></li> <li><code>forceUpdate</code>执行新旧<code>vnode</code>比对和<code>diff</code>，最后更新<code>dom</code></li></ol> <h3 id="domdiff"><a href="#domdiff" class="header-anchor">#</a> domdiff</h3> <ol><li><code>oldNode</code>有，<code>newNode</code>无，或者<code>oldNode</code>无，<code>newNode</code>有，则直接进行删除或者新增操作</li> <li><code>oldNode</code>和<code>newNode</code>的<code>type</code>值或者<code>key</code>不一样，则直接进行替换操作</li> <li><code>oldNode</code>和<code>newNode</code>的<code>type</code>和<code>key</code>都一样，则进行<code>domdiff</code>来获取<code>patch</code></li></ol> <h4 id="-2"><a href="#-2" class="header-anchor">#</a></h4> <h3 id="react-的-fiber-架构"><a href="#react-的-fiber-架构" class="header-anchor">#</a> react 的 fiber 架构</h3> <h4 id="requestidlecallback-调度逻辑"><a href="#requestidlecallback-调度逻辑" class="header-anchor">#</a> requestIdleCallback 调度逻辑</h4> <ul><li><code>nextUnitOfWork</code>记录下一个调度任务</li> <li><code>workloop</code>调度 diff 或者渲染任务
<ul><li><code>deadLine.timeRemaining()</code>判断当前帧是否结束</li> <li>如果有下一个任务，并且当前帧结束</li> <li>则执行下一个调度任务</li></ul></li> <li><code>requestIdleCallback</code>启动空闲时间去处理任务</li> <li><code>performUnitOfWork</code>获取下一个调度任务</li></ul> <h4 id="fiber"><a href="#fiber" class="header-anchor">#</a> fiber</h4> <p>任务为深度遍历</p> <ul><li><code>root</code>去找子元素</li> <li>子元素接着去找子元素</li> <li>如果没有子元素则找兄弟元素</li> <li>兄弟元素如果有子元素则接着找子元素</li> <li>如果没有子元素则找父元素</li></ul> <h3 id="网络安全（攻击手段）"><a href="#网络安全（攻击手段）" class="header-anchor">#</a> 网络安全（攻击手段）</h3> <h4 id="xss"><a href="#xss" class="header-anchor">#</a> xss</h4> <p><code>cross site scripting</code> 跨站脚本攻击</p> <p>运行非本站的<code>JavaScript</code>脚本</p> <p>防御手段：</p> <ul><li><p>浏览器默认防御：X-XSS-Protection，如果设置 0，则关闭默认防御</p></li> <li><p>CSP：可以设置禁止加载本站外的资源</p></li> <li><p>标签转译，可以借助<code>xss</code>这个库进行转译</p></li> <li><p>http only：使 js 无法读取 cookie</p></li></ul> <h4 id="csrf"><a href="#csrf" class="header-anchor">#</a> CSRF</h4> <p><code>Cross site Request Forgery</code> 跨站请求伪造</p> <p>利用用户已登录的身份，在用户不知情下，以用户的名义完成非法操作</p> <p>在 A 网站登录时。登录 B 网站。在 B 网站利用<code>iframe</code>加载 A 网站，并使用<code>form</code>表单<code>target</code>设置为 A 网站。利用用户在 A 网站的登陆状态发起请求</p> <p>防御手段：</p> <ul><li>利用<code>referer</code>判断是否是本网站发起的请求。但是<code>https</code>不发送<code>referer</code></li> <li>重要请求要使用验证码</li> <li><code>cookie</code>值进行<code>hash</code>：A 网站在请求时，不仅仅验证<code>hash</code>，请求中还带有随机数。</li></ul> <h4 id="clickjacking"><a href="#clickjacking" class="header-anchor">#</a> clickjacking</h4> <p>点击劫持，一种视觉欺骗攻击手段</p> <p>在 B 网站套 A 网站的<code>iframe</code>，设置为透明，设置到某个和诱惑按钮重合的位置。诱惑用户点击</p> <p>防御手段：</p> <ul><li>X-frame-options
<ul><li><code>deny</code>：不允许被<code>iframe</code>加载</li> <li><code>sameorigin</code>：只可被同域名的<code>iframe</code>加载</li> <li>allow-from：设置白名单</li></ul></li></ul> <h4 id="sql-注入"><a href="#sql-注入" class="header-anchor">#</a> SQL 注入</h4> <p>拼接<code>sql</code>，可能被万能密码入侵</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">table</span>
<span class="token keyword">where</span> name <span class="token operator">=</span> ${name}
<span class="token operator">and</span> pwd <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">or</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span>
</code></pre></div><p>防御</p> <ul><li>使用？占位符。[]传参的方式</li> <li>限制数据库权限</li></ul> <h4 id="os-注入"><a href="#os-注入" class="header-anchor">#</a> os 注入</h4> <p>用户输入的内容可以在命令行中执行的时候</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&quot;git clone ${params}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
params <span class="token operator">=</span> <span class="token string">&quot;https://xxx &amp;&amp; rm -rf /* &quot;</span><span class="token punctuation">;</span>
<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&quot;git clone https://xxx &amp;&amp; rm -rf /* &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="请求劫持"><a href="#请求劫持" class="header-anchor">#</a> 请求劫持</h4> <ul><li><code>DNS</code>劫持：<code>dns</code>服务器地址被篡改。</li> <li><code>http</code>劫持：运营商劫持？？？，升级<code>https</code></li></ul> <h4 id="ddos"><a href="#ddos" class="header-anchor">#</a> DDOS</h4> <p><code>distributed denial of service</code></p> <p>常见方式</p> <ul><li>syn flood：向目标发送具有欺骗性源 ip 地址的大量 tcp 初始链接请求。syn 包来利用 tcp 握手，目标机器响应每个连接请求，等待最后一步，这一步从未发生过，耗尽了进程中的目标资源</li> <li>http flood：不停的访问你的页面</li></ul> <p>防御手段</p> <ul><li>备份网站</li> <li><code>http</code>请求的拦截，高防<code>ip</code></li> <li>扩容服务器</li></ul> <h3 id="网络安全（防御手段）"><a href="#网络安全（防御手段）" class="header-anchor">#</a> 网络安全（防御手段）</h3> <h4 id="用户密码保存手段"><a href="#用户密码保存手段" class="header-anchor">#</a> 用户密码保存手段</h4> <p>将密码进行<code>md5</code>加密再加盐来提高密码复杂度</p> <h4 id="加密"><a href="#加密" class="header-anchor">#</a> 加密</h4> <p>REC 原理：阮一峰</p> <p>https://www.josephxia.com//</p> <ul><li>对称加密：加密和解密都使用同一个秘钥</li> <li>不对称加密：公钥加密，私钥解密。<code>github</code>代码库上传密码时上传的就是本地生成的公钥</li></ul> <p><code>https</code>加密验证过程</p> <p><img src="https://wx4.sinaimg.cn/mw690/a0940ce6gy1gcmtwfhhx0j20zn0l8q9g.jpg" alt=""></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/shimingw/vpblog/edit/master/docs/源码学习笔记/01.源码习笔记1.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">更新于:</span> <span class="time">2020-4-17 5:59:19 PM</span></div></footer> <!----> </main></div><div class="global-ui"><div class="pace  pace-inactive" style="display:none;" data-v-57a75e74><div data-progress-text="100%" data-progress="99" class="pace-progress" style="transform:translate3d(0%, 0px, 0px);" data-v-57a75e74><div class="pace-progress-inner" data-v-57a75e74></div></div></div><div class="my-popup" style="display:none;" data-v-3414bdeb><div class="my-popup-container" data-v-3414bdeb><div class="my-popup-exit" data-v-3414bdeb></div> <img src="" alt data-v-3414bdeb></div></div><!----><!----><div></div></div></div>
    <script src="/assets/js/app.750d9439.js" defer></script><script src="/assets/js/2.8423ab85.js" defer></script><script src="/assets/js/66.c587177b.js" defer></script><script src="/assets/js/5.d4f27e5e.js" defer></script>
  </body>
</html>
