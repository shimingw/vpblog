---
title: "Php"
date: 2018-04-25
permalink: "2018-04-25-其他-Php"
---





### namespace

```php
include 'nameSpace.php';		//引入php文件
$r = new \Other\Flag();			//使用引入文件下的命名空间下的类

use方法可以引入某个命名空间下具体的类，也可以使用as来修改同名的类来调用
```



### 类中声明函数的方法

- public:权限是最大的，可以内部调用，实例调用等。
- protected: 受保护类型，用于本类和继承类调用。
		可以class内部调用，实例化调用报错。
		可以被继承
- private: 私有类型，只有在本类中使用。
		可以class内部调用，实例化调用报错。
		不可以被继承


### this,self,parent的区别

- this：就是指向当前对象实例的指针，不指向任何其他对象或类
		new声明后指向声明后的对象
- self：是指向类本身，也就是self是不指向任何已经实例化的对象
		self使用::来调用类中的静态方法或变量
		静态方法中无法使用$this指针
- parent：是指向父类的指针，一般我们使用parent来调用父类的构造函数


### 魔术函数

```php
__construct函数：在类被实例化的时候触发
class name {
    function __construct()
    {
        echo 111111;
    }
    function __destruct()
    {
        // TODO: Implement __destruct() method.
        echo  222222;
    }
}
```



## Directory and File Functions

 The following directory and file functions should be used in Zend modules. They behave exactly like their C counterparts, but provide virtual working directory support on the thread level. 

| Zend Function      | Regular C Function                       |
| ------------------ | ---------------------------------------- |
| **V_GETCWD()**     | [**getcwd()**](itss://chm/zh/function.getcwd.html) |
| **V_FOPEN()**      | [**fopen()**](itss://chm/zh/function.fopen.html) |
| **V_OPEN()**       | **open()**                               |
| **V_CHDIR()**      | [**chdir()**](itss://chm/zh/function.chdir.html) |
| **V_GETWD()**      | **getwd()**                              |
| **V_CHDIR_FILE()** | Takes a file path as an argument and changes the current working directory to that file's directory. |
| **V_STAT()**       | [**stat()**](itss://chm/zh/function.stat.html) |
| **V_LSTAT()**      | [**lstat()**](itss://chm/zh/function.lstat.html) |





### abstract class 声明类

abstract类中声明函数时家protected和public有什么区别；

注意到在abstract class中 f1函数是**protected**，但是在subclass中我们可以将其声明为public的。no any visibility is less restricted than public.



```php
abstract class AbstractClass
{
    // 强制要求子类定义这些方法
    abstract protected function getValue();
    abstract protected function prefixValue($prefix);

    // 普通方法（非抽象方法）
    public function printOut() {
        print $this->getValue() . "\n";
    }
}
//继承的子类必须声明，父类中abstract声明过的函数，否则会报错

class ConcreteClass1 extends AbstractClass
{
    protected function getValue() {
        return "ConcreteClass1";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass1";
    }
}

```



### Interface

在interface中，只能使用**public**，而不能使用诸如protected和private

可以用**extends**关键字来继承interface，好像class那样

还可以继承多个interface

```php
interface a
{
    public function foo();
}

interface b extends a
{
    public function baz(Baz $baz);
}

```

你的class也可以implements**多个**interface

```php
interface template1
{
    public function f1();
}

interface template2
{
    public function f2();
}

class test implments template1, template2
{
    public
    function f1()
    {
//your function body
    }

    public
    function f2()
    {
//your function body
    }
}
```



### Abstract Class和Interface之间的不同：

#### 没有理解第四点

1. In abstract classes this is not necessary that every method should be abstract. But in interface every method is abstract.

在Abstract class中并非所有的method都必须是抽象的，但是在interface中所有的method都自动成为抽象的。就是在子类中必须声明和实现

2. Multiple and multilevel both type of inheritance is possible in interface. But single and multilevel inheritance is possible in abstract classes.

multiple和multilevel inheritance，我不知道改怎么翻译更好，multiple inheritance意思是 在interface中，一个class可以同时implements好多个interface；但是在abstract classes中，只能extends一个class。

当然你extends的这个class可能又extentds别的class，这就是所谓的multilevel inheritance。

3. Method of php interface must be public only. Method in abstract class in php could be public or protected both.

interface中的method必须是public的，但是在abstract class中可以是public或者protected。

4. In abstract class you can define as well as declare methods. But in interface you can only defined your methods.

在abstract class中你可以同时声明（declare）和定义（define）methodes，但是在interface中你只能定义那个methods


## 6.22

问题：
路由：channel/rate
方法：

问题1：

```php
static静态关键字的作用
与self的区别(private)
class BaseRepository
{
    protected static $model_class;

    public static function getSingleModel($condition)
    {
        $static = static::$model_class;
        return $static::where($condition)->first();
    }

    public static function getModels($condition)
    {
        $static = static::$model_class;
        return $static::where($condition)->get();
    }

    public static function update($condition, $update)
    {
        $static = static::$model_class;
        return $static::where($condition)->update($update);
    }

    public static function create(array $condition)
    {
        $static = static::$model_class;
        return $static::create($condition);
    }
}
```



问题2：

```php
PaymentRate
model模型中有一些属性不理解
protected static $model_class = PaymentRate::class;
是什么意思
```

问题3：

```php
自带的默认分页方法？
new LengthAwarePaginator($items->forPage($page, $pageSize), $items->count(), $pageSize);
```