(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{280:function(e,t,a){"use strict";a.r(t);var s=a(2),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"es6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[e._v("#")]),e._v(" ES6")]),e._v(" "),a("h2",{attrs:{id:"es6-声明变量的六种方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6-声明变量的六种方法"}},[e._v("#")]),e._v(" ES6 声明变量的六种方法")]),e._v(" "),a("p",[e._v("ES5 只有两种声明变量的方法："),a("code",[e._v("var")]),e._v("命令和"),a("code",[e._v("function")]),e._v("命令。ES6除了添加"),a("code",[e._v("let")]),e._v("和"),a("code",[e._v("const")]),e._v("命令，后面章节还会提到，另外两种声明变量的方法："),a("code",[e._v("import")]),e._v("命令和"),a("code",[e._v("class")]),e._v("命令。所以，ES6 一共有6种声明变量的方法。")]),e._v(" "),a("h2",{attrs:{id:"map-的-for-of-循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-的-for-of-循环"}},[e._v("#")]),e._v(" Map  的 for of  循环")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor(let [key,value] of map){\n    console.log(key + \"  is  \" + value);\n}\n")])])]),a("h1",{attrs:{id:"函数的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数的扩展"}},[e._v("#")]),e._v(" [函数的扩展]")]),e._v(" "),a("p",[e._v("1、函数传参，可以设置默认参数")]),e._v(" "),a("p",[e._v("2、引入rest参数代替arguments对象")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function add(...values) {\n  let sum = 0;\n  for (var val of values) {\n    sum += val;\n  }\n  return sum;\n}\n\nadd(2, 5, 3) // 10\n")])])]),a("p",[e._v("3、字符串")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("3.1可以将传入的字符串解析成数组\nfunction test(str) {\n    console.log([...str]);\n    console.log(str.length);\n    return [...str].length;\n}\nvar x = test(\"qwe\");\nconsole.log(x);\n\n3.2使用...解析字符串与split解析。\nlet str = 'x\\uD83D\\uDE80y';\nstr.split('').reverse().join('')\n[...str].reverse().join('')\n\n3.3实现了Iterator接口的对象\n实现了Iterator接口的对象可以直接使用[...]来转化成数组\nvar nodeList = document.querySelectorAll('div');\nvar array = [...nodeList];\n没有部署Iterator的对象\n比如\n\n")])])]),a("p",[e._v("4、箭头函数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("4.1箭头函数中的this指向定义时所在的作用域\nes5的匿名函数中的this指向运行时所在的作用域\n\nvar handler = {\n        id: '123456',\n        init: function() {\n            document.addEventListener('click', event => {\n                console.log(this);\n                this.doSomething(event.type);\n            }, false);\n        },\n        initSec: function() {\n            document.addEventListener('click',function (event) {\n                console.log(this);\n                this.doSomething(event.type)\n            });\n        },\n\n        doSomething: function(type) {\n            console.log('Handling ' + type  + ' for ' + this.id);\n        }\n    };\n\nhandler.init();\nhandler.initSec();\n\n4.2  arguments、super、new.target 在箭头函数中不存在\n4.3  箭头函数不能用call()、apply()、bind()这些方法去改变this的指向\n")])])]),a("h3",{attrs:{id:"尾调用的使用及优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尾调用的使用及优化"}},[e._v("#")]),e._v(" 尾调用的使用及优化")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("尾调用不需要保存外部函数的调用帧，可以提高性能\n最后返回的是一个函数\n\n我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n")])])]),a("h3",{attrs:{id:"尾递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尾递归"}},[e._v("#")]),e._v(" 尾递归")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("这种递归需要保存n个调用记录，会占用过多的内存\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\nfactorial(5) // 120\n\n尾递归调用方法\n返回的函数中total用来保存结果值\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\n")])])]),a("h1",{attrs:{id:"数组的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组的扩展"}},[e._v("#")]),e._v(" 数组的扩展")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("copyWithin,拷贝数组\n[].copyWithin(target, start = 0, end = this.length)\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("find() 和 findIndex()\nfind:可以过滤筛选数组\nfindIndex:返回第一个匹配中的数组中值得index\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("fill():使用给定值填充数组\nfill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\n()，keys() 和 values()\n三种数组的遍历方法\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("includes()\n查看数组中是否含有该值，返回布尔值\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("filter() 方法\n如果return true则保留\n如果return false则不保留\narray.filter(function(){\n  return false/true\n})\n")])])]),a("h1",{attrs:{id:"对象的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的扩展"}},[e._v("#")]),e._v(" 对象的扩展")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var cart = {\n        _wheels: 4,\n\n        get wheels () {\n            return this._wheels;\n        },\n\n        set wheels (value) {\n            if (value < this._wheels) {\n                throw new Error('数值太小了！');\n            }\n            this._wheels = value;\n        }\n    };\n\n    console.log(cart._wheels);\n\ncart.wheels = 1;\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("getOwnPropertyDescriptor\n获取对象上某个属性的，默认熟悉\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.is()\n比较两个值是否完全相等\n相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0\nObject.is('foo', 'foo')完美解决了这个问题\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.assign()\n对象合并方法，第一个参数是目标对象，后面的参数都是源对象。\n也可以用作对象拷贝。是浅拷贝，得到一个该对象的引用\n\n1、可以为对象添加属性\n    class Point {\n      constructor(x, y) {\n        Object.assign(this, {x, y});\n      }\n    }\n2、可以为对象添加方法\n    Object.assign(SomeClass.prototype, {\n      someMethod(arg1, arg2) {\n        ···\n      },\n      anotherMethod() {\n        ···\n      }\n    });\n   \n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('getPrototypeOf 从对象捕获原型。从而给原型添加方法\nvar spaghetti = new Pasta("wheat", 0.2);\n// Obtain the prototype from the object.\nvar proto = Object.getPrototypeOf(spaghetti);\n另外，ES6规定，所有Class的原型的方法都是不可枚举的。\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("属性的遍历\n1、for...in\nfor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。\n2、Object.keys(obj)\nObject.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。\n3、Object.getOwnPropertyNames(obj)\nObject.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。\n4、Object.getOwnPropertySymbols(obj)\nObject.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性。\n5、Reflect.ownKeys(obj)\nReflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("获取已数组的形式获取对象的所有值\nObject.keys():获取所有key\nObject.values():获取所有value\nObject.entries():获取所有key和value\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Null传导运算符\nconst firstName = message?.body?.user?.firstName || 'default';\n上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。\n")])])]),a("h1",{attrs:{id:"symbol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[e._v("#")]),e._v(" Symbol")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var s1 = Symbol();\nvar s2 = Symbol();\nObject.is(s1,s2)\t//false\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("作为属性名的 Symbol \nvar mySymbol = Symbol();\n\n// 第一种写法\nvar a = {};\na[mySymbol] = 'Hello!';\n\n// 第二种写法\nvar a = {\n  [mySymbol]: 'Hello!'\n};\n\n// 第三种写法\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello!' });\n\n// 以上写法都得到同样结果\na[mySymbol] // \"Hello!\"\n")])])]),a("h1",{attrs:{id:"set和map数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set和map数据结构"}},[e._v("#")]),e._v(" Set和Map数据结构")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Set 实例的属性和方法：\nnew Set()\nadd(value)：\t\t添加某个值，返回Set结构本身。\ndelete(value)：\t删除某个值，返回一个布尔值，表示删除是否成功。\nhas(value)：\t\t返回一个布尔值，表示该值是否为Set的成员。\nclear()：\t\t清除所有成员，没有返回值。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Array.from方法可以将 Set 结构转为数组。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("遍历操作：\nkeys()：\t\t返回键名的遍历器\nvalues()：\t返回键值的遍历器\nentries()：\t返回键值对的遍历器\nforEach()：\t使用回调函数遍历每个成员\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("WeakSet：\nnew WeakSet()\nWeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。\nWeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。\nWeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。\n\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Map：\nnew Map()\njson一定要使用字符串作为key值\nmap可以使用对象作为key值\n\nconst m = new Map();\nconst o = {p: 'Hello World'};\nm.set(o, 'content')\nm.get(o) // \"content\"\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('[]传值、...传值  方法\nconst items = [\n    [\'name\', \'张三\',111111],\n    [\'title\', \'Author\',22222222]\n];\nitems.forEach(([a1,a2,a3],b,c)=>{\n    console.log("a",a1)\n    console.log("a",a2)\n    console.log("a",a3)\n    console.log("b",b)\n    console.log("c",c)\n})\nitems.forEach((...key)=>{\n    console.log(key)\n})\n')])])]),a("h2",{attrs:{id:"weakmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[e._v("#")]),e._v(" WeakMap")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const wm1 = new WeakMap();\nconst key = {foo: 1};\nwm1.set(key, 2);\nwm1.get(key) // \n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("WeakMap与Map的区别有两点:\n1、WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n2、WeakMap的键名所指向的对象，不计入垃圾回收机制。\n3、没有遍历操作，没有size属性\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("WeakMap的设计目的:\n有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用\n一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放内存。\n内部机制:\n它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("WeakMap 应用的典型场合就是 DOM 节点作为键名\n使用weakmap为元素添加事件，当元素被移除后该事件会自动移除，不会造成内存泄漏\nconst listener = new WeakMap();\n\nlistener.set(element1, handler1);\nlistener.set(element2, handler2);\n\nelement1.addEventListener('click', listener.get(element1), false);\nelement2.addEventListener('click', listener.get(element2), false);\n\n")])])]),a("h1",{attrs:{id:"proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("概述:\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var proxy = new Proxy(target, handler);\nnew Proxy()表示生成一个Proxy实例\ntarget:参数表示所要拦截的目标对象.\nhandler:参数也是一个对象，用来定制拦截行为。\n例如:\nvar proxy = new Proxy({}, {\n  get: function(target, property) {\n    return 35;\n  }\n});\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("拦截方法:\n（1）get(target, propKey, receiver)\n\n拦截对象属性的读取，比如proxy.foo和proxy['foo']。\n\n最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。\n\n（2）set(target, propKey, value, receiver)\n\n拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。\n\n（3）has(target, propKey)\n\n拦截propKey in proxy的操作，返回一个布尔值。\n\n（4）deleteProperty(target, propKey)\n\n拦截delete proxy[propKey]的操作，返回一个布尔值。\n\n（5）ownKeys(target)\n\n拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。\n\n（6）getOwnPropertyDescriptor(target, propKey)\n\n拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。\n\n（7）defineProperty(target, propKey, propDesc)\n\n拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。\n\n（8）preventExtensions(target)\n\n拦截Object.preventExtensions(proxy)，返回一个布尔值。\n\n（9）getPrototypeOf(target)\n\n拦截Object.getPrototypeOf(proxy)，返回一个对象。\n\n（10）isExtensible(target)\n\n拦截Object.isExtensible(proxy)，返回一个布尔值。\n\n（11）setPrototypeOf(target, proto)\n\n拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。\n\n如果目标对象是函数，那么还有两种额外操作可以拦截。\n\n（12）apply(target, object, args)\n\n拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\n\n（13）construct(target, args)\n\n拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.create()可以继承proxy对象的规则\nlet obj = Object.create(proto);\n")])])]),a("h1",{attrs:{id:"reflect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reflect"}},[e._v("#")]),e._v(" Reflect")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("静态方法:\nReflect对象一共有13个静态方法。\n  Reflect.apply(target,thisArg,args)\n  Reflect.construct(target,args)\n  Reflect.get(target,name,receiver)\n  Reflect.set(target,name,value,receiver)\n  Reflect.defineProperty(target,name,desc)\n  Reflect.deleteProperty(target,name)\n  Reflect.has(target,name)\n  Reflect.ownKeys(target)\n  Reflect.isExtensible(target)\n  Reflect.preventExtensions(target)\n  Reflect.getOwnPropertyDescriptor(target, name)\n  Reflect.getPrototypeOf(target)\n  Reflect.setPrototypeOf(target, prototype)\n")])])]),a("h1",{attrs:{id:"promise-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象"}},[e._v("#")]),e._v(" Promise 对象")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('使用方法:\n  var promise = new Promise(function(resolve, reject) {\n      if(0){\n          resolve(1111111111);\n      }else{\n          reject(2222222222);\n      }\n  });\n\n执行:\n  promise.then(function(value) {\n      // success\n      console.log("value",value)\n  }, function(error) {\n      // failure\n      console.log("error",error)\n  });\n或者这么写\n  promise.then(function(value) {\n    // success\n    console.log("value",value)\n}).catch(error => {\n    // failure\n    console.log("error",error)\n});\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Promise.prototype.then() \n在then的方法里    throw new Error(\'test\'); 会被catch捕捉到。\nthen方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数\npromise.then(function(value) {\n    // success\n    console.log("value",value)\n    return "akjshdajksdh";\n}).then(json=>{\n    console.log("json",json)\n}).catch(error => {\n    // failure\n    console.log("error",error)\n});\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("如果Promise状态已经变成Resolved，再抛出错误是无效的。\n只能在then里抛出\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Promise.all() \n如果使用all()，就不需要再每个promise实例中写cathc方法。\nPromise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）\n例子:\nconst databasePromise = connectDatabase();\nconst booksPromise = databasePromise\n  .then(findAllBooks);\nconst userPromise = databasePromise\n  .then(getCurrentUser);\nPromise.all([\n  booksPromise,\n  userPromise\n])\n.then(([books, user]) => pickTopRecommentations(books, user));\n上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Promise.race()\nvar p = Promise.race([p1, p2, p3]);\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Promise.resolve()\n作用:将现有对象转为Promise对象.\n（1）参数是一个Promise实例:\n如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。\n（2）参数是一个thenable对象\nthenable对象指的是具有then方法的对象，比如下面这个对象。\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n（3）参数不是具有then方法的对象，或根本就不是对象:\n如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。\nvar p = Promise.resolve('Hello');\np.then(function (s){\n  console.log(s)\t\t//Hello\n});\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Promise.reject()\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected\n与上述的方法类似\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("done()方法\t(问题！！！！)\ndone方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。\n  asyncFunc()\n    .then(f1)\n    .catch(r1)\n    .then(f2)\n    .done();\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("finally() \t(问题！！！！)\nfinally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\n")])])]),a("h1",{attrs:{id:"iterator-和-for-of-循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iterator-和-for-of-循环"}},[e._v("#")]),e._v(" Iterator 和 for...of 循环")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\n必须具备Iterator属性的对象才可以使用for of循环\n1、数组。\n\t配合keys()，values()，entries()丰富for--of遍历的方法\n2、字符串\n\t每个字符串被当做一个值来进行遍历\n3、对象\n\t必须配合object下的keys()，values()，entries()方法，对对象进行转换，对转换后值得值进行遍历。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("NodeList对象:\n节点的集合\n具备Iterator接口并且具备数组所拥有的属性\n但是是死的对象，不会因为节点跟新而变化\n\nHTMLCollection对象:\n具备Iterator接口,但是不具备数组的属性\n但他是活的; 当底层文档更改时，它会自动更新。\n")])])]),a("h1",{attrs:{id:"generator-函数的语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator-函数的语法"}},[e._v("#")]),e._v(" Generator 函数的语法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Generator 函数是一个普通函数，但是有两个特征:\n一是，function关键字与函数名之间有一个星号；\n二是，函数体内部使用yield表达式，定义不同的内部状态\n\n知识点:\nGenerator只有调用next方法时，函数才会执行。\n\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("next()方法可以传值\n用来表示上文中yield的值\n")])])]),a("h3",{attrs:{id:"这两个章节没有细看"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这两个章节没有细看"}},[e._v("#")]),e._v(" 这两个章节没有细看")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Generator 函数的语法\nGenerator 函数的异步应用\n")])])]),a("h1",{attrs:{id:"class-的基本语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-的基本语法"}},[e._v("#")]),e._v(" Class 的基本语法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("constructor 方法\n通过new命令生成对象实例时，自动调用该方法\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("类的实例对象\n实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）\nconstructor中定义的属性方法在其本身\n其他的属性方法都在class上\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Class 表达式\n这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类\nconst MyClass = class Me {\n  getClassName() {\n    return Me.name;\n  }\n};\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Class 的取值函数（getter）和存值函数（setter）\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Class 的 Generator 方法\n如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Class 的静态方法 \n如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("静态属性添加方法(不能被继承)\nclass Foo {\n}\nFoo.prop = 1;\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new.target属性\n可以判断方法被执行的时候是不是被new出来的\n还是直接执行的\n")])])]),a("h1",{attrs:{id:"class-的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-的继承"}},[e._v("#")]),e._v(" Class 的继承")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("super关键字\nconstructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。\n重点：\n1、this是调用子类的方法\n2、super是调用父类的方法\n3、子类的constructor方法中的super()方法是调用父类的constructor方法\n4、子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例\n\nclass Point {\n    test(){\n        console.log(\"qew\")\n    }\n}\n\nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y); // 调用父类的constructor(x, y)\n        console.log(this)\n        console.log(x)\n        console.log(y)\n        console.log(color)\n        this.color = color;\n    }\n\n    toString() {\n        return this.color + ' ' + super.toString(); // 调用父类的toString()\n    }\n\n    mix () {\n        super.test();\n    }\n}\n\nvar qqq = new ColorPoint(1,2,3)\nqqq.mix();\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("es5的继承方式\n1、创造子类的实例对象this\n2、将父类的方法添加到this上面(Parent.apply(this))\n\nes6的继承方式\n1、先创造父类的实例对象this（所以必须先调用super方法）\n2、再用子类的构造函数修改this\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("super 关键字\n1、super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n2、super作为对象时，在普通方法中，指向父类的原型对象；在静态方法(static)中，指向父类。\n3、通过super调用父类的方法时，super会绑定子类的this。\n4、super 对象只可以调用父类上prototype下的属性和方法\n")])])]),a("h3",{attrs:{id:"类的-prototype-属性和-proto-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的-prototype-属性和-proto-属性"}},[e._v("#")]),e._v(" 类的 prototype 属性和__proto__属性")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、子类的__proto__属性，表示构造函数的继承，总是指向父类。\n2、子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\n")])])]),a("h3",{attrs:{id:"extends-的继承目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extends-的继承目标"}},[e._v("#")]),e._v(" extends 的继承目标")]),e._v(" "),a("h3",{attrs:{id:"实例的-proto-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例的-proto-属性"}},[e._v("#")]),e._v(" 实例的 "),a("strong",[e._v("proto")]),e._v(" 属性")]),e._v(" "),a("h3",{attrs:{id:"原生构造函数的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生构造函数的继承"}},[e._v("#")]),e._v(" 原生构造函数的继承")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。\nBoolean()\nNumber()\nString()\nArray()\nDate()\nFunction()\nRegExp()\nError()\nObject()\n以前，这些原生构造函数是无法继承的\n现在可以使用extends继承\n")])])]),a("h1",{attrs:{id:"修饰器-es2017"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修饰器-es2017"}},[e._v("#")]),e._v(" 修饰器(ES2017)")]),e._v(" "),a("p",[e._v("1、类的修饰")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("为类添加新的属性方法\n")])])]),a("h1",{attrs:{id:"module-的语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#module-的语法"}},[e._v("#")]),e._v(" Module 的语法")]),e._v(" "),a("h3",{attrs:{id:"_1、概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、概述"}},[e._v("#")]),e._v(" 1、概述")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、ES6 模块的设计思想，是尽量的静态化\n\n2、CommonJS 和 AMD 模块，都只能在运行时确定这些东西\n\tlet { stat, exists, readFile } = require('fs');\n\t整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\n\t\n3、通过export命令显式指定输出的代码，再通过import命令输入。\n\timport { stat, exists, readFile } from 'fs';\n\t从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，效率要比 CommonJS 模块的加载方式高\n")])])]),a("h3",{attrs:{id:"_3、export-命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、export-命令"}},[e._v("#")]),e._v(" 3、export 命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export命令用于规定模块的对外接口\nimport命令用于输入其他模块提供的功能。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export写法\n1、export var firstName = 'Michael';\n\texport var lastName = 'Jackson';\n2、var firstName = 'Michael';\n\tvar lastName = 'Jackson';\n\texport {firstName, lastName};\n3、export还可以直接输出类或者方法\n4、使用as关键字重命名\n\texport {\n\t  v1 as streamV1,\n\t};\n")])])]),a("h3",{attrs:{id:"_4、import-命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、import-命令"}},[e._v("#")]),e._v(" 4、import 命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、import {firstName, lastName, year} from './profile';\n2、import { lastName as surname } from './profile';\n3、import命令是编译阶段执行的，在代码运行之前\n4、import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\n5、import 'lodash';\n\t仅仅执行lodash模块\n")])])]),a("h3",{attrs:{id:"_5、模块的整体加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、模块的整体加载"}},[e._v("#")]),e._v(" 5、模块的整体加载")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import * as circle from './circle';\n将circle这个文件的输出（类、方法、变量）全部定义到circle这个对象下面\n")])])]),a("h3",{attrs:{id:"_6、export-default-命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、export-default-命令"}},[e._v("#")]),e._v(" 6、export default 命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export default function () {\n  console.log('foo');\n}\n加载的时候可以指定任意名字\n")])])]),a("h3",{attrs:{id:"_7、export-与-import-的复合写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、export-与-import-的复合写法"}},[e._v("#")]),e._v(" 7、export 与 import 的复合写法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export { foo, bar } from 'my_module';\n// 等同于\nimport { foo, bar } from 'my_module';\nexport { foo, bar };\n")])])]),a("h1",{attrs:{id:"module-的加载实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#module-的加载实现"}},[e._v("#")]),e._v(" Module 的加载实现")]),e._v(" "),a("h4",{attrs:{id:"_1、浏览器加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、浏览器加载"}},[e._v("#")]),e._v(" 1、浏览器加载")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('defer：渲染完再执行、如果有多个defer脚本，会按照它们在页面出现的顺序加载\nasync：下载完就执行、不能保证加载顺序\n浏览器对于带有type="module"的<script>，都是异步加载\n等同于打开了<script>标签的defer属性\n')])])]),a("h4",{attrs:{id:"_2、es6-模块与-commonjs-模块的差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、es6-模块与-commonjs-模块的差异"}},[e._v("#")]),e._v(" 2、ES6 模块与 CommonJS 模块的差异")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\nCommonJS 模块输出的是值的拷贝\nimport\t模块输出的值是引用值(\n\t所有的变量与类都是引用的同一个\n)\n\n")])])]),a("h4",{attrs:{id:"_3、node-加载（es6模块加载与commonjs的差异）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、node-加载（es6模块加载与commonjs的差异）"}},[e._v("#")]),e._v(" 3、Node 加载（es6模块加载与commonJS的差异）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、Node 对 ES6 模块的处理比较麻烦\n\tCommonJS 模块格式，与 ES6 模块格式是不兼容的\n\t目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案\n2、在静态分析阶段，一个模块脚本只要有一行import或export语句，Node 就会认\t为该脚本为 ES6 模块，否则就为 CommonJS 模块\n3、如果不输出任何接口，但是希望被 Node 认为是 ES6 模块，可以在脚本中加一行\t语句。\n\texport {};\n4、ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。\n5、module.exports等同于export default、只能输出一次。\n")])])]),a("h4",{attrs:{id:"_4、import-命令加载-commonjs-模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、import-命令加载-commonjs-模块"}},[e._v("#")]),e._v(" 4、import 命令加载 CommonJS 模块")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、CommonJS 模块输出都定义在module.exports这个属性上面\n2、使用import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default\n")])])]),a("h4",{attrs:{id:"_5、require-命令加载-es6-模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、require-命令加载-es6-模块"}},[e._v("#")]),e._v(" 5、require 命令加载 ES6 模块")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("require在家es6模块时，会把该模块中的所有属性方法成为输入对象的属性\n")])])]),a("h4",{attrs:{id:"_6、循环加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、循环加载"}},[e._v("#")]),e._v(" 6、循环加载")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("CommonJS模块的加载原理\n1、CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象\n2、由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ES6 模块的循环加载\nES6模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\n")])])]),a("h1",{attrs:{id:"编程风格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编程风格"}},[e._v("#")]),e._v(" 编程风格")]),e._v(" "),a("h4",{attrs:{id:"_1、块级作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、块级作用域"}},[e._v("#")]),e._v(" 1、块级作用域")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("（1）let 取代 var\n（2）全局常量和线程安全\n\t在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\n")])])]),a("h4",{attrs:{id:"_2、字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、字符串"}},[e._v("#")]),e._v(" 2、字符串")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。\n`反引号内可以使用${}来设置变量\nconst b = `foo${a}bar`;\n")])])]),a("h4",{attrs:{id:"_3、解构赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、解构赋值"}},[e._v("#")]),e._v(" 3、解构赋值")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、使用数组成员对变量赋值时，优先使用解构赋值。\n\t数组：const [first, second] = arr;\n\t对象：const { firstName, lastName } = obj;(obj中必须包含这两key值)\n    // best\n    function getFullName({ firstName, lastName }) {\n    }\n2、对函数返回对象的解构赋值\n    function processInput() {\n        let left = {\n            name:1\n        };\n        let right = {\n            name:2\n        };\n        return { left, right };\n    }\n    const {left,right} = processInput();\n")])])]),a("h4",{attrs:{id:"_4、对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、对象"}},[e._v("#")]),e._v(" 4、对象")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。\n    // good\n    const a = { k1: v1, k2: v2 };\n    const b = {\n      k1: v1,\n      k2: v2,\n    };\n    \n2、对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。\n3、如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。\n4、对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。\n    var ref = 'some value';\n      var obj = {\n      ref\n    };\n")])])]),a("h4",{attrs:{id:"_5、数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、数组"}},[e._v("#")]),e._v(" 5、数组")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、使用扩展运算符（...）拷贝数组。\n2、使用Array.from方法，将类似数组的对象转为数组。\n")])])]),a("h4",{attrs:{id:"_6、函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、函数"}},[e._v("#")]),e._v(" 6、函数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、立即执行函数可以写成箭头函数的形式。\n  (() => {\n    console.log('Welcome to the Internet.');\n  })();\n  \n2、箭头函数中的this与普通函数中的this(调用和定义的区别)\n\t箭头函数中的this\n\t1、总是代表它的直接调用者, 例如 obj.func ,那么func中的this就是obj\n\t2、在默认情况(非严格模式下,未使用 'use strict'),没找到直接调用者,则this指的是 window\n\t3、在严格模式下,没有直接调用者的函数中的this是 undefined\n\t4、使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象\n\n\t普通函数中的this\n\t1、函数被定义时的this指向\n")])])]),a("h4",{attrs:{id:"_7、map结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、map结构"}},[e._v("#")]),e._v(" 7、Map结构")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。\n")])])]),a("h4",{attrs:{id:"_8、class"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、class"}},[e._v("#")]),e._v(" 8、class")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。\n2、使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。\n")])])]),a("h4",{attrs:{id:"_9、模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、模块"}},[e._v("#")]),e._v(" 9、模块")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1、Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。\n2、使用export取代module.exports。\n3、如果模块只有一个输出值，就使用export default\n4、如果模块默认输出一个函数，函数名的首字母应该小写。\n5、如果模块默认输出一个对象，对象名的首字母应该大写。\n")])])]),a("h4",{attrs:{id:"_10、eslint的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、eslint的使用"}},[e._v("#")]),e._v(" 10、ESLint的使用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。\n")])])]),a("h1",{attrs:{id:"读懂-ecmascript-规格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读懂-ecmascript-规格"}},[e._v("#")]),e._v(" 读懂 ECMAScript 规格")])])}),[],!1,null,null,null);t.default=n.exports}}]);