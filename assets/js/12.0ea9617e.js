(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{285:function(t,n,a){"use strict";a.r(n);var e=a(2),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"注释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[t._v("#")]),t._v(" 注释")]),t._v(" "),a("p",[a("code",[t._v("js")]),t._v("中存在2中注释")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("//")])]),t._v(" "),a("li",[a("code",[t._v("/* */")])])]),t._v(" "),a("p",[t._v("推荐使用第一种，因为第二种，在以下情景会造成错误")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/*\n    var rm_a = /a*/.match(s)\n*/\n")])])]),a("h3",{attrs:{id:"数字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数字"}},[t._v("#")]),t._v(" 数字")]),t._v(" "),a("p",[a("code",[t._v("js")]),t._v("只有一个数字类型，他在内部被表示为64位的浮点数，和"),a("code",[t._v("java")]),t._v("的"),a("code",[t._v("double")]),t._v("（双精度浮点数）一样")]),t._v(" "),a("h3",{attrs:{id:"字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[t._v("#")]),t._v(" 字符串")]),t._v(" "),a("p",[a("strong",[t._v("转义字符")]),t._v("：用来把那些正常情况下被允许的字符插入到字符串中，比如反斜杠、引号和控制字符。使用"),a("code",[t._v("\\u")]),t._v("约定用来指定数字字符编码")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("序列")]),t._v(" "),a("th",[t._v("代表字符")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("\\0")]),t._v(" "),a("td",[t._v("Null字符（\\u0000）")])]),t._v(" "),a("tr",[a("td",[t._v("\\b")]),t._v(" "),a("td",[t._v("退格符（\\u0008）")])]),t._v(" "),a("tr",[a("td",[t._v("\\t")]),t._v(" "),a("td",[t._v("水平制表符（\\u0009）")])]),t._v(" "),a("tr",[a("td",[t._v("\\n")]),t._v(" "),a("td",[t._v("换行符（\\u000A）")])]),t._v(" "),a("tr",[a("td",[t._v("\\v")]),t._v(" "),a("td",[t._v("垂直制表符（\\u000B）")])]),t._v(" "),a("tr",[a("td",[t._v("\\f")]),t._v(" "),a("td",[t._v("换页符（\\u000C）")])]),t._v(" "),a("tr",[a("td",[t._v("\\r")]),t._v(" "),a("td",[t._v("回车符（\\u000D）")])]),t._v(" "),a("tr",[a("td",[t._v('"')]),t._v(" "),a("td",[t._v("双引号（\\u0022）")])]),t._v(" "),a("tr",[a("td",[t._v("'")]),t._v(" "),a("td",[t._v("撇号或单引号（\\u0027）")])]),t._v(" "),a("tr",[a("td",[t._v("\\")]),t._v(" "),a("td",[t._v("反斜杠（\\u005C）")])]),t._v(" "),a("tr",[a("td",[t._v("\\xXX")]),t._v(" "),a("td",[t._v("由 2 位十六进制数值 XX 指定的 Latin-1 字符")])]),t._v(" "),a("tr",[a("td",[t._v("\\uXXXX")]),t._v(" "),a("td",[t._v("由 4 位十六进制数值 XXXX 指定的 Unicode 字符")])]),t._v(" "),a("tr",[a("td",[t._v("\\XXX")]),t._v(" "),a("td",[t._v("由 1~3 位八进制数值（000 到 377）指定的 Latin-1 字符，可表示 256个 字符。如 \\251 表示版本符号。注意，ECMAScript 3.0 不支持，考虑到兼容性不建议使用。")])])])]),t._v(" "),a("h3",{attrs:{id:"布尔值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#布尔值"}},[t._v("#")]),t._v(" 布尔值")]),t._v(" "),a("p",[t._v("以下的值在"),a("code",[t._v("js")]),t._v("中被认为是"),a("code",[t._v("false")])]),t._v(" "),a("ul",[a("li",[t._v("false")]),t._v(" "),a("li",[t._v("null")]),t._v(" "),a("li",[t._v("undefined")]),t._v(" "),a("li",[t._v("空字符串' '")]),t._v(" "),a("li",[t._v("数字0")]),t._v(" "),a("li",[t._v("数字NaN")])]),t._v(" "),a("p",[t._v("其他所有的值都被当做真，包括字符串"),a("code",[t._v("“false”")]),t._v("，以及所有的对象")]),t._v(" "),a("h3",{attrs:{id:"函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),a("h4",{attrs:{id:"函数调用模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数调用模式"}},[t._v("#")]),t._v(" 函数调用模式")]),t._v(" "),a("p",[t._v("当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用")]),t._v(" "),a("p",[t._v("以此模式调用函数时，"),a("code",[t._v("this")]),t._v("被绑定到全局对象。这是语言设计上的一个错误。正确设计应该是，当内部函数被调用时，"),a("code",[t._v("this")]),t._v("应该绑定到外部作用域的"),a("code",[t._v("this")]),t._v("变量。")]),t._v(" "),a("p",[t._v("这个缺陷在"),a("strong",[t._v("es6")]),t._v("中可以使用"),a("strong",[t._v("箭头函数")]),t._v("来避免")]),t._v(" "),a("p",[t._v("例如：")]),t._v(" "),a("p",[t._v("在下面这个方法中"),a("code",[t._v("help1")]),t._v("输出的是"),a("code",[t._v("window")]),t._v("，"),a("code",[t._v("help2")]),t._v("输出的是"),a("code",[t._v("myObj")]),t._v("对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const myObj = {}\nmyObj.double = function () {\n    const help1 = function () {\n        console.log(this);\n    }\n    const help2 = ()=>{\n        console.log(this);\n    }\n    help1()\n    help2()\n}\nmyObj.double()\n")])])]),a("h4",{attrs:{id:"尾递归优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尾递归优化"}},[t._v("#")]),t._v(" 尾递归优化")]),t._v(" "),a("p",[t._v("如果一个函数返回自身递归调用的结果，那么调用的过程会被替换为一个循环，它可以显著提高速度")]),t._v(" "),a("h5",{attrs:{id:"优化前"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化前"}},[t._v("#")]),t._v(" 优化前")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function fact(n) {\n    if (n <= 0) {\n        return 1;\n    } else {\n        return n * fact(n - 1);\n    }\n}\n")])])]),a("p",[t._v("递归栈")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("6 * fact(5)\n6 * (5 * fact(4))\n6 * (5 * (4 * fact(3))))\n// two thousand years later...\n6 * (5 * (4 * (3 * (2 * (1 * 1)))))) // <= 最终的展开\n")])])]),a("h5",{attrs:{id:"优化后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化后"}},[t._v("#")]),t._v(" 优化后")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function fact(n, r) {\n    if (n <= 0) {\n        return 1 * r;\n    } else {\n        return fact(n - 1, r * n);\n    }\n}\n")])])]),a("p",[t._v("递归栈")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fact(6, 1) // 1 是 fact(0) 的值，我们需要手动写一下\nfact(5, 6)\nfact(4, 30)\nfact(3, 120)\nfact(2, 360)\nfact(1, 720)\n720 // <= 最终的结果\n")])])]),a("h4",{attrs:{id:"作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),a("p",[t._v("很多现代语言都推荐尽可能延迟声明变量")]),t._v(" "),a("p",[t._v("因为，如果if分支抛出异常，此时变量encrypted就不会被使用，并且需要承受string 的构造和析构成本。\n所以应尽量在变量要使用的地方再去定义它")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("encryptPassword(password) {\n    const encrypted = encrypt(password);\n    if(password.length() < MinimumPasswordLengt) {  \n        throw (“Password is too short”)  \n    }  \n    //必要动作，将一个加密后的密码置入encrypted内。  \n    return encypted;\n}\n")])])]),a("p",[t._v("修改如下")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("encryptPassword(password) {\n    if(password.length() < MinimumPasswordLengt) {  \n        throw (“Password is too short”)  \n    }  \n    //必要动作，将一个加密后的密码置入encrypted内。  \n    const encrypted = encrypt(password);\n    return encypted;  \n}  \n")])])]),a("h4",{attrs:{id:"模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[t._v("#")]),t._v(" 模块")]),t._v(" "),a("p",[t._v("我们可以使用函数和闭包来构造模块")]),t._v(" "),a("p",[t._v("第一种：没有采取闭包的方式，每次执行"),a("code",[t._v("deentityify")]),t._v("时，"),a("code",[t._v("entity")]),t._v("变量都会被求值一次，会带来运行时的损耗")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("String.prototype.deentityify = function() {\n  const entity = {\n    quot: '\"',\n    lt: '<',\n    gt: '>'\n  }\n  return this.replace(/&([^&;]+);/g, function(a, b) {\n    const r = entity[b]\n    return typeof r === 'string' ? r : a\n  })\n}\n'&lt;&quot;&gt;'.deentityify()\n")])])]),a("p",[t._v("第二种：采取闭包的方式，只有"),a("code",[t._v("deentityify")]),t._v("方法才有权访问"),a("code",[t._v("entity")]),t._v("变量，既做到了不污染全局变量，又做到了，减少运行时带来的损耗")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("String.prototype.deentityify = function() {\n  const entity = {\n    quot: '\"',\n    lt: '<',\n    gt: '>'\n  }\n  const that = this\n  return (function() {\n    return that.replace(/&([^&;]+);/g, function(a, b) {\n      const r = entity[b]\n      return typeof r === 'string' ? r : a\n    })\n  })()\n}\n'&lt;&quot;&gt;'.deentityify()\n")])])]),a("h4",{attrs:{id:"单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[t._v("#")]),t._v(" 单例模式")]),t._v(" "),a("p",[t._v("用对象字面量表示法创建的对象，对象的属性值可以是数值或函数，并且属性值在该对象的生命周期中不会发生变化，它通常作为工具为程序的其他部分提供功能支持。")]),t._v(" "),a("p",[t._v("优点")]),t._v(" "),a("ul",[a("li",[t._v("由于内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了")]),t._v(" "),a("li",[t._v("单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。")])]),t._v(" "),a("p",[t._v("缺点")]),t._v(" "),a("ul",[a("li",[t._v("单例模式没有抽象层，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。")]),t._v(" "),a("li",[t._v("单例类的职责过重，在一定程度上违背了“单一职责原则”。")])]),t._v(" "),a("h4",{attrs:{id:"级联"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#级联"}},[t._v("#")]),t._v(" 级联")]),t._v(" "),a("p",[t._v("让方法返回"),a("code",[t._v("this")]),t._v("而不是"),a("code",[t._v("undefined")])]),t._v(" "),a("h4",{attrs:{id:"柯里化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[t._v("#")]),t._v(" 柯里化")]),t._v(" "),a("p",[t._v("一个简单柯里化函数的实现")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Function.prototype.curry = function(...initParams) {\n  return (...curryParams) =>\n    this.apply(null, initParams.concat(curryParams))\n}\nconst add = (a, b) => a + b\nconst add1 = add.curry(1)\nconsole.log(add1(6))\t//=>7\n")])])]),a("h4",{attrs:{id:"记忆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#记忆"}},[t._v("#")]),t._v(" 记忆")]),t._v(" "),a("p",[t._v("利用闭包，函数可以将先前操作的结果记录在某个对象里，从而避免无所谓的重复计算")]),t._v(" "),a("p",[a("code",[t._v("compute")]),t._v("只有打印了一次")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const add = (function() {\n  const cache = {}\n  const addMem = (a, b) => {\n    if (typeof cache[a + b] !== 'number') {\n      cache[a + b] = a + b\n      console.log('compute')\n      return a + b\n    }\n    return cache[a + b]\n  }\n  return addMem\n})()\nadd(1, 1)\nadd(1, 1)\nadd(1, 1)\nadd(1, 1)\nadd(1, 1)\n")])])]),a("h3",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),a("h4",{attrs:{id:"组合继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组合继承"}},[t._v("#")]),t._v(" 组合继承")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("js")]),t._v("的"),a("code",[t._v("prototype")]),t._v("属性来实现继承")]),t._v(" "),a("p",[t._v("使子类的"),a("code",[t._v("prototype")]),t._v("属性指向父类实例，可以实现继承。因为，"),a("code",[t._v("js")]),t._v("调用时会通过原型链逐级查找调用")]),t._v(" "),a("p",[t._v("但是会存在2个问题")]),t._v(" "),a("ul",[a("li",[t._v("在子类中无法访问"),a("code",[t._v("super")]),t._v("（父类）方法")]),t._v(" "),a("li",[t._v("如果在调用构造器函数时忘了在前面加"),a("code",[t._v("new")]),t._v("，那么"),a("code",[t._v("this")]),t._v("会绑定到"),a("code",[t._v("window")]),t._v("上，污染全局变量")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const body = function(type) {\n  this.type = type\n}\nbody.prototype.sayName = function() {\n  console.log(this.name)\n}\nconst smw = function(name) {\n  this.name = name\n  this.type = 123\n}\nconst bodyExa = new body('people')\nsmw.prototype = bodyExa\nconst smwBody = new smw('smw')\nsmwBody.sayName()\nconsole.log(smwBody.type)\n\nconst bodyExa = body('people')\n")])])]),a("h4",{attrs:{id:"object-create继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-create继承"}},[t._v("#")]),t._v(" Object.create继承")]),t._v(" "),a("p",[t._v("原型式继承")]),t._v(" "),a("p",[t._v("利用"),a("code",[t._v("Object.create")]),t._v("来实现原型的继承")]),t._v(" "),a("p",[t._v("对象的原型继承")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const obj1 = {\n  name: '1111111'\n}\nconst obj2 = Object.create(obj1)\nconsole.log(obj2)\n")])])]),a("p",[a("code",[t._v("function")]),t._v("的原型继承")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const fn1 = function(name) {\n  this.name = name\n}\nfn1.prototype.say = function() {\n  console.log(this.name)\n}\nconst fn2 = Object.create(new fn1('smw'))\nconsole.log(fn2)\n")])])]),a("h4",{attrs:{id:"寄生组合式继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合式继承"}},[t._v("#")]),t._v(" 寄生组合式继承")]),t._v(" "),a("p",[t._v("优化组合继承")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Student.prototype = new Person()  //未优化的时候   Person实例充当原型链的中间对象（缓冲）\n-------------------------\nStudent.prototype = Object.create(Person.prototype) //优化后    一个继承Person的空对象充当中间对象（缓冲）\n------------------------\nStudent.prototype.__proto__ = Person.prototype  //当然也有人这么写  道理都是一样，Student.prototype.__proto__做缓冲\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'use strict'\n\nfunction _inheritsLoose(subClass, superClass) {\n  // 使子类在被实例化时继承父类的方法\n  subClass.prototype = Object.create(superClass.prototype)\n  //这一句可以让子类.constructor.name由 父类 变为子类， 方便确认构造函数\n  subClass.prototype.constructor = subClass\n  // static 变量值继承\n  subClass.__proto__ = superClass\n}\n\nvar parent =\n  /*#__PURE__*/\n  (function() {\n    function parent() {\n      this.name = 'smw'\n    }\n\n    var _proto = parent.prototype\n\n    _proto.sayName = function sayName() {\n      console.log(this.name)\n    }\n\n    return parent\n  })()\n\nvar child =\n  /*#__PURE__*/\n  (function(_parent) {\n    _inheritsLoose(child, _parent)\n\n    function child(age) {\n      var _this\n\n      //   使父类方法挂在到子类的this上\n      _this = _parent.call(this) || this\n      _this.age = age\n      // 返回的对象即为child的this\n      return _this\n    }\n\n    var _proto2 = child.prototype\n\n    _proto2.sayAge = function sayAge() {\n    // 这里可以通过_parent.prototype访问父类上的方法\n      console.log(this.age)\n    }\n\n    return child\n  })(parent)\n\nvar c = new child(1)\nc.sayName()\nc.sayAge()\n\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);