(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{261:function(t,e,a){"use strict";a.r(e);var n=a(2),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"namespace"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#namespace"}},[t._v("#")]),t._v(" namespace")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("include 'nameSpace.php';\t\t//引入php文件\n$r = new \\Other\\Flag();\t\t\t//使用引入文件下的命名空间下的类\n\nuse方法可以引入某个命名空间下具体的类，也可以使用as来修改同名的类来调用\n")])])]),a("h3",{attrs:{id:"类中声明函数的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类中声明函数的方法"}},[t._v("#")]),t._v(" 类中声明函数的方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public:权限是最大的，可以内部调用，实例调用等。\nprotected: 受保护类型，用于本类和继承类调用。\n\t\t可以class内部调用，实例化调用报错。\n\t\t可以被继承\nprivate: 私有类型，只有在本类中使用。\n\t\t可以class内部调用，实例化调用报错。\n\t\t不可以被继承\n")])])]),a("h3",{attrs:{id:"this-self-parent的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-self-parent的区别"}},[t._v("#")]),t._v(" this,self,parent的区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("this：就是指向当前对象实例的指针，不指向任何其他对象或类\n\t\tnew声明后指向声明后的对象\nself：是指向类本身，也就是self是不指向任何已经实例化的对象\n\t\tself使用::来调用类中的静态方法或变量\n\t\t静态方法中无法使用$this指针\nparent：是指向父类的指针，一般我们使用parent来调用父类的构造函数\n")])])]),a("h3",{attrs:{id:"魔术函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#魔术函数"}},[t._v("#")]),t._v(" 魔术函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("__construct函数：在类被实例化的时候触发\nclass name {\n    function __construct()\n    {\n        echo 111111;\n    }\n    function __destruct()\n    {\n        // TODO: Implement __destruct() method.\n        echo  222222;\n    }\n}\n")])])]),a("h1",{attrs:{id:"directory-and-file-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#directory-and-file-functions"}},[t._v("#")]),t._v(" Directory and File Functions")]),t._v(" "),a("p",[t._v("The following directory and file functions should be used in Zend modules. They behave exactly like their C counterparts, but provide virtual working directory support on the thread level.")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Zend Function")]),t._v(" "),a("th",[t._v("Regular C Function")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[t._v("V_GETCWD()")])]),t._v(" "),a("td",[a("router-link",{attrs:{to:"itss://chm/zh/function.getcwd.html"}},[a("strong",[t._v("getcwd()")])])],1)]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("V_FOPEN()")])]),t._v(" "),a("td",[a("router-link",{attrs:{to:"itss://chm/zh/function.fopen.html"}},[a("strong",[t._v("fopen()")])])],1)]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("V_OPEN()")])]),t._v(" "),a("td",[a("strong",[t._v("open()")])])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("V_CHDIR()")])]),t._v(" "),a("td",[a("router-link",{attrs:{to:"itss://chm/zh/function.chdir.html"}},[a("strong",[t._v("chdir()")])])],1)]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("V_GETWD()")])]),t._v(" "),a("td",[a("strong",[t._v("getwd()")])])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("V_CHDIR_FILE()")])]),t._v(" "),a("td",[t._v("Takes a file path as an argument and changes the current working directory to that file's directory.")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("V_STAT()")])]),t._v(" "),a("td",[a("router-link",{attrs:{to:"itss://chm/zh/function.stat.html"}},[a("strong",[t._v("stat()")])])],1)]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("V_LSTAT()")])]),t._v(" "),a("td",[a("router-link",{attrs:{to:"itss://chm/zh/function.lstat.html"}},[a("strong",[t._v("lstat()")])])],1)])])]),t._v(" "),a("h3",{attrs:{id:"abstract-class-声明类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract-class-声明类"}},[t._v("#")]),t._v(" abstract class 声明类")]),t._v(" "),a("p",[t._v("abstract类中声明函数时家protected和public有什么区别；")]),t._v(" "),a("p",[t._v("注意到在abstract class中 f1函数是"),a("strong",[t._v("protected")]),t._v("，但是在subclass中我们可以将其声明为public的。no any visibility is less restricted than public.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('abstract class AbstractClass\n{\n    // 强制要求子类定义这些方法\n    abstract protected function getValue();\n    abstract protected function prefixValue($prefix);\n\n    // 普通方法（非抽象方法）\n    public function printOut() {\n        print $this->getValue() . "\\n";\n    }\n}\n//继承的子类必须声明，父类中abstract声明过的函数，否则会报错\n\nclass ConcreteClass1 extends AbstractClass\n{\n    protected function getValue() {\n        return "ConcreteClass1";\n    }\n\n    public function prefixValue($prefix) {\n        return "{$prefix}ConcreteClass1";\n    }\n}\n\n\n')])])]),a("h3",{attrs:{id:"interface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interface"}},[t._v("#")]),t._v(" Interface")]),t._v(" "),a("p",[t._v("在interface中，只能使用"),a("strong",[t._v("public")]),t._v("，而不能使用诸如protected和private")]),t._v(" "),a("p",[t._v("可以用"),a("strong",[t._v("extends")]),t._v("关键字来继承interface，好像class那样")]),t._v(" "),a("p",[t._v("还可以继承多个interface")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("interface a\n{\n    public function foo();\n}\n\ninterface b extends a\n{\n    public function baz(Baz $baz);\n}\n\n")])])]),a("p",[t._v("你的class也可以implements"),a("strong",[t._v("多个")]),t._v("interface")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("interface template1\n{\n    public function f1();\n}\n\ninterface template2\n{\n    public function f2();\n}\n\nclass test implments template1, template2\n{\n    public\n    function f1()\n    {\n//your function body\n    }\n\n    public\n    function f2()\n    {\n//your function body\n    }\n}\n")])])]),a("h3",{attrs:{id:"abstract-class和interface之间的不同："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract-class和interface之间的不同："}},[t._v("#")]),t._v(" Abstract Class和Interface之间的不同：")]),t._v(" "),a("h4",{attrs:{id:"没有理解第四点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没有理解第四点"}},[t._v("#")]),t._v(" 没有理解第四点")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. In abstract classes this is not necessary that every method should be abstract. But in interface every method is abstract.\n\n在Abstract class中并非所有的method都必须是抽象的，但是在interface中所有的method都自动成为抽象的。就是在子类中必须声明和实现\n\n2. Multiple and multilevel both type of inheritance is possible in interface. But single and multilevel inheritance is possible in abstract classes.\n\nmultiple和multilevel inheritance，我不知道改怎么翻译更好，multiple inheritance意思是 在interface中，一个class可以同时implements好多个interface；但是在abstract classes中，只能extends一个class。\n\n当然你extends的这个class可能又extentds别的class，这就是所谓的multilevel inheritance。\n\n3. Method of php interface must be public only. Method in abstract class in php could be public or protected both.\n\ninterface中的method必须是public的，但是在abstract class中可以是public或者protected。\n\n4. In abstract class you can define as well as declare methods. But in interface you can only defined your methods.\n\n在abstract class中你可以同时声明（declare）和定义（define）methodes，但是在interface中你只能定义那个methods\n")])])]),a("h2",{attrs:{id:"_6-22"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-22"}},[t._v("#")]),t._v(" 6.22")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("问题：\n路由：channel/rate\n方法：\n\n")])])]),a("p",[t._v("问题1：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("static静态关键字的作用\n与self的区别(private)\nclass BaseRepository\n{\n    protected static $model_class;\n\n    public static function getSingleModel($condition)\n    {\n        $static = static::$model_class;\n        return $static::where($condition)->first();\n    }\n\n    public static function getModels($condition)\n    {\n        $static = static::$model_class;\n        return $static::where($condition)->get();\n    }\n\n    public static function update($condition, $update)\n    {\n        $static = static::$model_class;\n        return $static::where($condition)->update($update);\n    }\n\n    public static function create(array $condition)\n    {\n        $static = static::$model_class;\n        return $static::create($condition);\n    }\n}\n")])])]),a("p",[t._v("问题2：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("PaymentRate\nmodel模型中有一些属性不理解\nprotected static $model_class = PaymentRate::class;\n是什么意思\n")])])]),a("p",[t._v("问题3：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("自带的默认分页方法？\nnew LengthAwarePaginator($items->forPage($page, $pageSize), $items->count(), $pageSize);\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);