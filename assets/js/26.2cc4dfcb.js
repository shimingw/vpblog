(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{302:function(t,a,e){"use strict";e.r(a);var s=e(10),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class\n控制class是否添加\n    <span v-bind:class='{red:addClass}'>{{text}}</span>\n\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("数据双向绑定\nv-model\n指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("自定义指令\nv-focus\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("钩子函数\nupdate\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("选项对象\ncomputed\n")])])]),e("h2",{attrs:{id:"vue-注册组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-注册组件"}},[t._v("#")]),t._v(" vue 注册组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\tVue.component('todo-item', {\n  // todo-item 组件现在接受一个\n  // \"prop\"，类似于一个自定义属性\n  // 这个属性名为 todo。\n  props: ['todo'],\n  template: '<li>{{ todo.text }}</li>'\n})\n")])])]),e("h3",{attrs:{id:"vue-生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[t._v("#")]),t._v(" Vue 生命周期")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("beforeCreate\ncreated\nbeforeMount\nmounted\nbeforeUpdate\nupdated\nactivated\ndeactivated\nbeforeDestroy\ndestroyed\n")])])]),e("h3",{attrs:{id:"vue-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-指令"}},[t._v("#")]),t._v(" vue 指令")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(' v-bind 指令：\n \t用来绑定一些属性\n \t<div v-bind:id="dynamicId"></div>\n \t<button v-bind:disabled="isButtonDisabled">Button</button>\n \t缩写：\n\t \t<a :href="url"></a>\n\n\n v-if指令：\n \t传入布尔值，用来控制元素是否显示\n\n v-on 指令：\n \t用于监听 DOM 事件\n \t<a v-on:click="doSomething">\n \t缩写：\n\t \t<a @click="doSomething"></a>\n')])])]),e("h3",{attrs:{id:"vue-修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-修饰符"}},[t._v("#")]),t._v(" vue 修饰符")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定\n\t例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：\n\t<form v-on:submit.prevent="onSubmit"></form>\n')])])]),e("h3",{attrs:{id:"vue-过滤语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-过滤语法"}},[t._v("#")]),t._v(" vue 过滤语法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("{{ message | capitalize }}\n    var data = { message: \"akjsdakjsdhjkasdh\" };\n    var vm = new Vue({\n      el: '#app',\n      data: data,\n      filters: {\n        capitalize: function (value) {\n          console.log(value)\n          return value;\n        }\n      }\n    });\n")])])]),e("h1",{attrs:{id:"vue-route"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-route"}},[t._v("#")]),t._v(" Vue-route")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\n")])])]),e("h1",{attrs:{id:"ajax-请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajax-请求"}},[t._v("#")]),t._v(" ajax 请求")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("开发环境\n\t通过配置proxyTable 代理请求\n\n生产环境\n\t通过设置完成url路径\n")])])]),e("h1",{attrs:{id:"组件的通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件的通信"}},[t._v("#")]),t._v(" 组件的通信")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('可以将标签内的数据传入组件中\n<custom-select btn="查询"></custom-select>\n使用props将数据传入组件\nprops:["btn"]\n<input type="button" :value="btn">\n在子组件中使用{{}}来接收数据\n\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("要把组件中的data写成一个方法\n是为了当多个地方使用一个组件时，不让其他组件的数据相互影响\n每个组件使用独立的数据\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('使用is来扩展标签\n<table>\n\t<tr is="custom-select"></tr>\n</table>\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("利用自定义事件来实现父子组件之间的通信\n使用this.$emit()来触发以及传值\n")])])]),e("h1",{attrs:{id:"vue-组件封装流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件封装流程"}},[t._v("#")]),t._v(" Vue 组件封装流程")]),t._v(" "),e("h4",{attrs:{id:"components"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#components"}},[t._v("#")]),t._v(" components")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var Child = {\n  template: '<div>A custom component!</div>'\n}\nexport default {\n  components: {\n    //在这个组件中注册使用的子组件\n    //例如以上配置\n     'my-component': Child\n  }\n}\n")])])]),e("h4",{attrs:{id:"props"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("props: ['todo']\n为该组件提供todo对象。\n\n传入这个封装好的组件中的值，可以设置type和require和default\n  props: {\n    apiUrl: {\n      type: String,\n      required: true\n    },\n    fields: {\n      type: Array,\n      required: true\n    },\n    sortOrder: {\n      type: Array,\n      default() {\n        return []\n      }\n    },\n    detailRowComponent: {\n      type: String\n    }\n  },\n")])])]),e("h4",{attrs:{id:"render"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[t._v("#")]),t._v(" render")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("用来代替template属性\n\nVue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 render 函数，它比 template 更接近编译器。\n\n    Vue.component('anchored-heading', {\n      render: function (createElement) {\n        return createElement(\n          'h' + this.level,   // tag name 标签名称\n          this.$slots.default // 子组件中的阵列\n        )\n      },\n      props: {\n        level: {\n          type: Number,\n          required: true\n        }\n      }\n    })\n")])])]),e("h4",{attrs:{id:"methods"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#methods"}},[t._v("#")]),t._v(" methods")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("事件处理器\nmethods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。\n")])])]),e("h4",{attrs:{id:"slot"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#slot"}},[t._v("#")]),t._v(" slot")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('具名slot\nname 来配置如何分发内容\n    <slot name="header"></slot>\n    可以渲染某个具体的模板\n    <h1 slot="header">\n    </h1>\n\n\n<slot> 标签中的任何内容都被视为备用内容\n')])])]),e("h4",{attrs:{id:"scope"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scope"}},[t._v("#")]),t._v(" scope")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('作用域插槽\nscope 的值对应一个临时变量名\n接收传递的props变量\n<div scope="props">\n    <span>{{props.text}}</span>\n</div>\n\nexport default{\n      data(){\n          return {\n            props:{\n                text:"hahahahah"\n            }\n          }\n      }\n  }\n\n')])])]),e("h1",{attrs:{id:"vue-获取对象属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-获取对象属性"}},[t._v("#")]),t._v(" vue 获取对象属性")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vm.$data\n获取vm的data数据属性\n\nvm.$el\n获取vm的dom属性\n\n\n")])])]),e("h4",{attrs:{id:"attr-属性绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#attr-属性绑定"}},[t._v("#")]),t._v(" attr 属性绑定")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('  <div v-bind:id="testId">\n  </div>\n')])])]),e("h4",{attrs:{id:"缩写"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缩写"}},[t._v("#")]),t._v(" 缩写")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('v-bind 缩写\n    \x3c!-- 完整语法 --\x3e\n    <a v-bind:href="url"></a>\n    \x3c!-- 缩写 --\x3e\n    <a :href="url"></a>\n\n\nv-on 缩写\n    \x3c!-- 完整语法 --\x3e\n    <a v-on:click="doSomething"></a>\n    \x3c!-- 缩写 --\x3e\n    <a @click="doSomething"></a>\n')])])]),e("h4",{attrs:{id:"computed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("计算属性\n\n注意，不应该使用箭头函数来定义计算属性函数 (例如 aDouble: () => this.a * 2)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。\n\n    computed: {\n      // 仅读取，值只须为函数\n      aDouble: function () {\n        return this.a * 2\n      },\n      // 读取和设置\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n")])])]),e("h2",{attrs:{id:"class-与-style-绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#class-与-style-绑定"}},[t._v("#")]),t._v(" Class 与 Style 绑定")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1、设置为true则，该属性显示\n\n    <div class=\"static\"\n         v-bind:class=\"{ active: isActive, 'text-danger': hasError }\">\n    </div>\n\n    data: {\n      isActive: true,\n      hasError: false\n    }\n\n2、也可以直接绑定数据里的一个对象：\n\n\t<div v-bind:class=\"classObject\"></div>\n\n    data: {\n      classObject: {\n        active: true,\n        'text-danger': false\n      }\n    }\n\n\n3、可以使用 computed 计算属性\n\n\tdata(){\n          return {\n            isActive: true,\n            error: null\n          }\n      },\n    computed: {\n      classObject: function () {\n        return {\n          active: true,\n          'text-danger': true,\n        }\n      }\n    }\n\n\n\n")])])]),e("h4",{attrs:{id:"v-if-vs-v-show"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-if-vs-v-show"}},[t._v("#")]),t._v(" v-if vs v-show")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" v-if 有更高的切换开销\n v-show 有更高的初始渲染开销\n\n 因此，如果需要非常频繁地切换，则使用 v-show 较好\n 如果在运行时条件不太可能改变，则使用 v-if 较好\n")])])]),e("h4",{attrs:{id:"v-for"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-for"}},[t._v("#")]),t._v(" v-for")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<li v-for="item in items">\n<li v-for="(item, index) in items">\n<li v-for="value in object">\n<div v-for="(value, key) in object">\n')])])]),e("h2",{attrs:{id:"构成组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构成组件"}},[t._v("#")]),t._v(" 构成组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("父子组件的关系可以总结为 props down, events up。\n\n父组件通过 props 向下传递数据给子组件。\n子组件通过 events 给父组件发送消息。\n\n注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。\n\n\n")])])]),e("h5",{attrs:{id:"prop-验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prop-验证"}},[t._v("#")]),t._v(" prop 验证")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  props: {\n    // 基础类型检测 (`null` 意思是任何类型都可以)\n    propA: Number,\n    // 多种类型\n    propB: [String, Number],\n    // 必传且是字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 数字，有默认值\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 数组/对象的默认值应当由一个工厂函数返回\n    propE: {\n      type: Object,\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        return value > 10\n      }\n    }\n  }\n")])])]),e("h4",{attrs:{id:"动态组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态组件"}},[t._v("#")]),t._v(" 动态组件")]),t._v(" "),e("h5",{attrs:{id:"v-bind-is"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-bind-is"}},[t._v("#")]),t._v(" V-bind:is")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("使用保留的 <component> 元素\n  <component :is=\"currentView\">\n      \x3c!-- 组件在 vm.currentview 变化时改变！ --\x3e\n  </component>\n\n  var Home = {\n    template: '<p>Welcome home!</p>'\n  }\n\n  export default{\n      data(){\n          return {\n            currentView: 'home'\n          }\n      },\n    components: {\n      home: Home,\n      posts: posts,\n    }\n  }\n\n")])])]),e("h5",{attrs:{id:"keep-alive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[t._v("#")]),t._v(" Keep-alive")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数\n组件会频繁切换时使用\n\n<keep-alive>\n  <component :is="currentView">\n    \x3c!-- 非活动组件将被缓存！ --\x3e\n  </component>\n</keep-alive>\n')])])]),e("h1",{attrs:{id:"编写可复用组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编写可复用组件"}},[t._v("#")]),t._v(" 编写可复用组件")]),t._v(" "),e("h5",{attrs:{id:"vue-组件的-api-来自三部分-props-events-和-slots-："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件的-api-来自三部分-props-events-和-slots-："}},[t._v("#")]),t._v(" Vue 组件的 API 来自三部分 - props, events 和 slots ：")]),t._v(" "),e("ol",[e("li",[t._v("Props 允许外部环境传递数据给组件")]),t._v(" "),e("li",[t._v("Events 允许从外部环境在组件内触发副作用")]),t._v(" "),e("li",[t._v("Slots 允许外部环境将额外的内容组合在组件中。")])]),t._v(" "),e("h4",{attrs:{id:"mixins-选项合并"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mixins-选项合并"}},[t._v("#")]),t._v(" mixins 选项合并")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("生命周期的钩子选项合并后将会，组成一个数组，都将调用\n\n值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。\n")])])]),e("h1",{attrs:{id:"vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" vuex")]),t._v(" "),e("h3",{attrs:{id:"vuex-调用方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-调用方法"}},[t._v("#")]),t._v(" vuex 调用方法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1、\nimport {store} from './testVuex'\n        store.commit('increment')\n每次这样从文件引入vuex的store然后对其进行操作很不方便\n\n2、Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）\n\n\n")])])]),e("h3",{attrs:{id:"mapstate-辅助函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mapstate-辅助函数"}},[t._v("#")]),t._v(" mapState 辅助函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n\nmapState  辅助函数帮助我们生成计算属性\n    computed: mapState({\n      // 箭头函数可使代码更简练\n      count: state => state.count\n    })\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);